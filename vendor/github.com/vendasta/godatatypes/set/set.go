// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package set

// NewBoolSet returns a new set. This is not thread safe.
func NewBoolSet(size ...int) BoolSet {
	if size != nil && len(size) > 0 {
		return make(map[bool]struct{}, size[0])
	}
	return make(map[bool]struct{})
}

// NewBoolSetFromSlice creates a set from a slice
func NewBoolSetFromSlice(sl []bool, size ...int) BoolSet {
	s := NewBoolSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// BoolSet stores the set values
type BoolSet map[bool]struct{}

// Add a value to the set
func (s BoolSet) Add(value bool) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s BoolSet) Remove(value bool) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s BoolSet) Contains(value bool) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s BoolSet) ToSlice() []bool {
	slice := make([]bool, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s BoolSet) Len() int {
	return len(s)
}

// NewByteSet returns a new set. This is not thread safe.
func NewByteSet(size ...int) ByteSet {
	if size != nil && len(size) > 0 {
		return make(map[byte]struct{}, size[0])
	}
	return make(map[byte]struct{})
}

// NewByteSetFromSlice creates a set from a slice
func NewByteSetFromSlice(sl []byte, size ...int) ByteSet {
	s := NewByteSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// ByteSet stores the set values
type ByteSet map[byte]struct{}

// Add a value to the set
func (s ByteSet) Add(value byte) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s ByteSet) Remove(value byte) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s ByteSet) Contains(value byte) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s ByteSet) ToSlice() []byte {
	slice := make([]byte, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s ByteSet) Len() int {
	return len(s)
}

// NewComplex128Set returns a new set. This is not thread safe.
func NewComplex128Set(size ...int) Complex128Set {
	if size != nil && len(size) > 0 {
		return make(map[complex128]struct{}, size[0])
	}
	return make(map[complex128]struct{})
}

// NewComplex128SetFromSlice creates a set from a slice
func NewComplex128SetFromSlice(sl []complex128, size ...int) Complex128Set {
	s := NewComplex128Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Complex128Set stores the set values
type Complex128Set map[complex128]struct{}

// Add a value to the set
func (s Complex128Set) Add(value complex128) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Complex128Set) Remove(value complex128) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Complex128Set) Contains(value complex128) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Complex128Set) ToSlice() []complex128 {
	slice := make([]complex128, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Complex128Set) Len() int {
	return len(s)
}

// NewComplex64Set returns a new set. This is not thread safe.
func NewComplex64Set(size ...int) Complex64Set {
	if size != nil && len(size) > 0 {
		return make(map[complex64]struct{}, size[0])
	}
	return make(map[complex64]struct{})
}

// NewComplex64SetFromSlice creates a set from a slice
func NewComplex64SetFromSlice(sl []complex64, size ...int) Complex64Set {
	s := NewComplex64Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Complex64Set stores the set values
type Complex64Set map[complex64]struct{}

// Add a value to the set
func (s Complex64Set) Add(value complex64) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Complex64Set) Remove(value complex64) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Complex64Set) Contains(value complex64) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Complex64Set) ToSlice() []complex64 {
	slice := make([]complex64, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Complex64Set) Len() int {
	return len(s)
}

// NewErrorSet returns a new set. This is not thread safe.
func NewErrorSet(size ...int) ErrorSet {
	if size != nil && len(size) > 0 {
		return make(map[error]struct{}, size[0])
	}
	return make(map[error]struct{})
}

// NewErrorSetFromSlice creates a set from a slice
func NewErrorSetFromSlice(sl []error, size ...int) ErrorSet {
	s := NewErrorSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// ErrorSet stores the set values
type ErrorSet map[error]struct{}

// Add a value to the set
func (s ErrorSet) Add(value error) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s ErrorSet) Remove(value error) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s ErrorSet) Contains(value error) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s ErrorSet) ToSlice() []error {
	slice := make([]error, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s ErrorSet) Len() int {
	return len(s)
}

// NewFloat32Set returns a new set. This is not thread safe.
func NewFloat32Set(size ...int) Float32Set {
	if size != nil && len(size) > 0 {
		return make(map[float32]struct{}, size[0])
	}
	return make(map[float32]struct{})
}

// NewFloat32SetFromSlice creates a set from a slice
func NewFloat32SetFromSlice(sl []float32, size ...int) Float32Set {
	s := NewFloat32Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Float32Set stores the set values
type Float32Set map[float32]struct{}

// Add a value to the set
func (s Float32Set) Add(value float32) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Float32Set) Remove(value float32) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Float32Set) Contains(value float32) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Float32Set) ToSlice() []float32 {
	slice := make([]float32, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Float32Set) Len() int {
	return len(s)
}

// NewFloat64Set returns a new set. This is not thread safe.
func NewFloat64Set(size ...int) Float64Set {
	if size != nil && len(size) > 0 {
		return make(map[float64]struct{}, size[0])
	}
	return make(map[float64]struct{})
}

// NewFloat64SetFromSlice creates a set from a slice
func NewFloat64SetFromSlice(sl []float64, size ...int) Float64Set {
	s := NewFloat64Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Float64Set stores the set values
type Float64Set map[float64]struct{}

// Add a value to the set
func (s Float64Set) Add(value float64) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Float64Set) Remove(value float64) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Float64Set) Contains(value float64) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Float64Set) ToSlice() []float64 {
	slice := make([]float64, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Float64Set) Len() int {
	return len(s)
}

// NewIntSet returns a new set. This is not thread safe.
func NewIntSet(size ...int) IntSet {
	if size != nil && len(size) > 0 {
		return make(map[int]struct{}, size[0])
	}
	return make(map[int]struct{})
}

// NewIntSetFromSlice creates a set from a slice
func NewIntSetFromSlice(sl []int, size ...int) IntSet {
	s := NewIntSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// IntSet stores the set values
type IntSet map[int]struct{}

// Add a value to the set
func (s IntSet) Add(value int) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s IntSet) Remove(value int) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s IntSet) Contains(value int) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s IntSet) ToSlice() []int {
	slice := make([]int, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s IntSet) Len() int {
	return len(s)
}

// NewInt16Set returns a new set. This is not thread safe.
func NewInt16Set(size ...int) Int16Set {
	if size != nil && len(size) > 0 {
		return make(map[int16]struct{}, size[0])
	}
	return make(map[int16]struct{})
}

// NewInt16SetFromSlice creates a set from a slice
func NewInt16SetFromSlice(sl []int16, size ...int) Int16Set {
	s := NewInt16Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Int16Set stores the set values
type Int16Set map[int16]struct{}

// Add a value to the set
func (s Int16Set) Add(value int16) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Int16Set) Remove(value int16) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Int16Set) Contains(value int16) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Int16Set) ToSlice() []int16 {
	slice := make([]int16, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Int16Set) Len() int {
	return len(s)
}

// NewInt32Set returns a new set. This is not thread safe.
func NewInt32Set(size ...int) Int32Set {
	if size != nil && len(size) > 0 {
		return make(map[int32]struct{}, size[0])
	}
	return make(map[int32]struct{})
}

// NewInt32SetFromSlice creates a set from a slice
func NewInt32SetFromSlice(sl []int32, size ...int) Int32Set {
	s := NewInt32Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Int32Set stores the set values
type Int32Set map[int32]struct{}

// Add a value to the set
func (s Int32Set) Add(value int32) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Int32Set) Remove(value int32) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Int32Set) Contains(value int32) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Int32Set) ToSlice() []int32 {
	slice := make([]int32, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Int32Set) Len() int {
	return len(s)
}

// NewInt64Set returns a new set. This is not thread safe.
func NewInt64Set(size ...int) Int64Set {
	if size != nil && len(size) > 0 {
		return make(map[int64]struct{}, size[0])
	}
	return make(map[int64]struct{})
}

// NewInt64SetFromSlice creates a set from a slice
func NewInt64SetFromSlice(sl []int64, size ...int) Int64Set {
	s := NewInt64Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Int64Set stores the set values
type Int64Set map[int64]struct{}

// Add a value to the set
func (s Int64Set) Add(value int64) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Int64Set) Remove(value int64) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Int64Set) Contains(value int64) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Int64Set) ToSlice() []int64 {
	slice := make([]int64, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Int64Set) Len() int {
	return len(s)
}

// NewInt8Set returns a new set. This is not thread safe.
func NewInt8Set(size ...int) Int8Set {
	if size != nil && len(size) > 0 {
		return make(map[int8]struct{}, size[0])
	}
	return make(map[int8]struct{})
}

// NewInt8SetFromSlice creates a set from a slice
func NewInt8SetFromSlice(sl []int8, size ...int) Int8Set {
	s := NewInt8Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Int8Set stores the set values
type Int8Set map[int8]struct{}

// Add a value to the set
func (s Int8Set) Add(value int8) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Int8Set) Remove(value int8) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Int8Set) Contains(value int8) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Int8Set) ToSlice() []int8 {
	slice := make([]int8, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Int8Set) Len() int {
	return len(s)
}

// NewRuneSet returns a new set. This is not thread safe.
func NewRuneSet(size ...int) RuneSet {
	if size != nil && len(size) > 0 {
		return make(map[rune]struct{}, size[0])
	}
	return make(map[rune]struct{})
}

// NewRuneSetFromSlice creates a set from a slice
func NewRuneSetFromSlice(sl []rune, size ...int) RuneSet {
	s := NewRuneSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// RuneSet stores the set values
type RuneSet map[rune]struct{}

// Add a value to the set
func (s RuneSet) Add(value rune) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s RuneSet) Remove(value rune) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s RuneSet) Contains(value rune) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s RuneSet) ToSlice() []rune {
	slice := make([]rune, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s RuneSet) Len() int {
	return len(s)
}

// NewStringSet returns a new set. This is not thread safe.
func NewStringSet(size ...int) StringSet {
	if size != nil && len(size) > 0 {
		return make(map[string]struct{}, size[0])
	}
	return make(map[string]struct{})
}

// NewStringSetFromSlice creates a set from a slice
func NewStringSetFromSlice(sl []string, size ...int) StringSet {
	s := NewStringSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// StringSet stores the set values
type StringSet map[string]struct{}

// Add a value to the set
func (s StringSet) Add(value string) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s StringSet) Remove(value string) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s StringSet) Contains(value string) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s StringSet) ToSlice() []string {
	slice := make([]string, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s StringSet) Len() int {
	return len(s)
}

// NewUintSet returns a new set. This is not thread safe.
func NewUintSet(size ...int) UintSet {
	if size != nil && len(size) > 0 {
		return make(map[uint]struct{}, size[0])
	}
	return make(map[uint]struct{})
}

// NewUintSetFromSlice creates a set from a slice
func NewUintSetFromSlice(sl []uint, size ...int) UintSet {
	s := NewUintSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// UintSet stores the set values
type UintSet map[uint]struct{}

// Add a value to the set
func (s UintSet) Add(value uint) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s UintSet) Remove(value uint) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s UintSet) Contains(value uint) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s UintSet) ToSlice() []uint {
	slice := make([]uint, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s UintSet) Len() int {
	return len(s)
}

// NewUint16Set returns a new set. This is not thread safe.
func NewUint16Set(size ...int) Uint16Set {
	if size != nil && len(size) > 0 {
		return make(map[uint16]struct{}, size[0])
	}
	return make(map[uint16]struct{})
}

// NewUint16SetFromSlice creates a set from a slice
func NewUint16SetFromSlice(sl []uint16, size ...int) Uint16Set {
	s := NewUint16Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Uint16Set stores the set values
type Uint16Set map[uint16]struct{}

// Add a value to the set
func (s Uint16Set) Add(value uint16) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Uint16Set) Remove(value uint16) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Uint16Set) Contains(value uint16) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Uint16Set) ToSlice() []uint16 {
	slice := make([]uint16, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Uint16Set) Len() int {
	return len(s)
}

// NewUint32Set returns a new set. This is not thread safe.
func NewUint32Set(size ...int) Uint32Set {
	if size != nil && len(size) > 0 {
		return make(map[uint32]struct{}, size[0])
	}
	return make(map[uint32]struct{})
}

// NewUint32SetFromSlice creates a set from a slice
func NewUint32SetFromSlice(sl []uint32, size ...int) Uint32Set {
	s := NewUint32Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Uint32Set stores the set values
type Uint32Set map[uint32]struct{}

// Add a value to the set
func (s Uint32Set) Add(value uint32) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Uint32Set) Remove(value uint32) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Uint32Set) Contains(value uint32) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Uint32Set) ToSlice() []uint32 {
	slice := make([]uint32, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Uint32Set) Len() int {
	return len(s)
}

// NewUint64Set returns a new set. This is not thread safe.
func NewUint64Set(size ...int) Uint64Set {
	if size != nil && len(size) > 0 {
		return make(map[uint64]struct{}, size[0])
	}
	return make(map[uint64]struct{})
}

// NewUint64SetFromSlice creates a set from a slice
func NewUint64SetFromSlice(sl []uint64, size ...int) Uint64Set {
	s := NewUint64Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Uint64Set stores the set values
type Uint64Set map[uint64]struct{}

// Add a value to the set
func (s Uint64Set) Add(value uint64) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Uint64Set) Remove(value uint64) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Uint64Set) Contains(value uint64) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Uint64Set) ToSlice() []uint64 {
	slice := make([]uint64, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Uint64Set) Len() int {
	return len(s)
}

// NewUint8Set returns a new set. This is not thread safe.
func NewUint8Set(size ...int) Uint8Set {
	if size != nil && len(size) > 0 {
		return make(map[uint8]struct{}, size[0])
	}
	return make(map[uint8]struct{})
}

// NewUint8SetFromSlice creates a set from a slice
func NewUint8SetFromSlice(sl []uint8, size ...int) Uint8Set {
	s := NewUint8Set(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// Uint8Set stores the set values
type Uint8Set map[uint8]struct{}

// Add a value to the set
func (s Uint8Set) Add(value uint8) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s Uint8Set) Remove(value uint8) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s Uint8Set) Contains(value uint8) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s Uint8Set) ToSlice() []uint8 {
	slice := make([]uint8, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s Uint8Set) Len() int {
	return len(s)
}

// NewUintptrSet returns a new set. This is not thread safe.
func NewUintptrSet(size ...int) UintptrSet {
	if size != nil && len(size) > 0 {
		return make(map[uintptr]struct{}, size[0])
	}
	return make(map[uintptr]struct{})
}

// NewUintptrSetFromSlice creates a set from a slice
func NewUintptrSetFromSlice(sl []uintptr, size ...int) UintptrSet {
	s := NewUintptrSet(size...)
	for _, sli := range sl {
		s.Add(sli)
	}
	return s
}

// UintptrSet stores the set values
type UintptrSet map[uintptr]struct{}

// Add a value to the set
func (s UintptrSet) Add(value uintptr) {
	s[value] = struct{}{}
}

// Remove a value from the set
func (s UintptrSet) Remove(value uintptr) {
	delete(s, value)
}

// Contains returns true if the value exists in the set, false if it does not
func (s UintptrSet) Contains(value uintptr) bool {
	_, found := s[value]
	return found
}

// ToSlice returns the set as a slice
func (s UintptrSet) ToSlice() []uintptr {
	slice := make([]uintptr, len(s))
	i := 0
	for k := range s {
		slice[i] = k
		i++
	}
	return slice
}

// Len returns the number of values in the set
func (s UintptrSet) Len() int {
	return len(s)
}
