// Code generated by protoc-gen-go. DO NOT EDIT.
// source: marketplace/v1/api.proto

/*
Package marketplace_v1 is a generated protocol buffer package.

It is generated from these files:
	marketplace/v1/api.proto

It has these top-level messages:
	GetOAuthTokenRequest
	GetOAuthTokenResponse
	GetSessionTransferURLRequest
	GetSessionTransferURLResponse
	CheckAccountPermissionRequest
	ListActiveAddonsRequest
	AddonActivation
	ListActiveAddonsResponse
	ListAssociatedUsersRequest
	User
	ListAssociatedUsersResponse
	GetSessionFromTokenRequest
	Session
	GetSessionFromTokenResponse
*/
package marketplace_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"
import google_protobuf1 "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// GetOAuthTokenRequest
type GetOAuthTokenRequest struct {
	// Use the following string: 'urn:ietf:params:oauth:grant-type:jwt-bearer'.
	GrantType string `protobuf:"bytes,1,opt,name=grant_type,json=grantType" json:"grant_type,omitempty"`
	// The JWT, including signature.
	Assertion string `protobuf:"bytes,2,opt,name=assertion" json:"assertion,omitempty"`
}

func (m *GetOAuthTokenRequest) Reset()                    { *m = GetOAuthTokenRequest{} }
func (m *GetOAuthTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOAuthTokenRequest) ProtoMessage()               {}
func (*GetOAuthTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GetOAuthTokenRequest) GetGrantType() string {
	if m != nil {
		return m.GrantType
	}
	return ""
}

func (m *GetOAuthTokenRequest) GetAssertion() string {
	if m != nil {
		return m.Assertion
	}
	return ""
}

// GetOAuthTokenResponse
type GetOAuthTokenResponse struct {
	// The token to use to authenticate all other API's with (set in the Authorization header).
	AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken" json:"access_token,omitempty"`
	// The type of token returned.
	TokenType string `protobuf:"bytes,2,opt,name=token_type,json=tokenType" json:"token_type,omitempty"`
	// A timestamp indicating when the access token is good until.
	Expires *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=expires" json:"expires,omitempty"`
}

func (m *GetOAuthTokenResponse) Reset()                    { *m = GetOAuthTokenResponse{} }
func (m *GetOAuthTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*GetOAuthTokenResponse) ProtoMessage()               {}
func (*GetOAuthTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetOAuthTokenResponse) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *GetOAuthTokenResponse) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *GetOAuthTokenResponse) GetExpires() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expires
	}
	return nil
}

// GetSessionTransferURLRequest
type GetSessionTransferURLRequest struct {
	// The Account ID.
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId" json:"account_id,omitempty"`
}

func (m *GetSessionTransferURLRequest) Reset()                    { *m = GetSessionTransferURLRequest{} }
func (m *GetSessionTransferURLRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSessionTransferURLRequest) ProtoMessage()               {}
func (*GetSessionTransferURLRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetSessionTransferURLRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

// GetSessionTransferURLResponse
type GetSessionTransferURLResponse struct {
	// The session transfer URL to send the user to (which may result in a redirect to a login screen).
	SessionTransferUrl string `protobuf:"bytes,1,opt,name=session_transfer_url,json=sessionTransferUrl" json:"session_transfer_url,omitempty"`
}

func (m *GetSessionTransferURLResponse) Reset()                    { *m = GetSessionTransferURLResponse{} }
func (m *GetSessionTransferURLResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSessionTransferURLResponse) ProtoMessage()               {}
func (*GetSessionTransferURLResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetSessionTransferURLResponse) GetSessionTransferUrl() string {
	if m != nil {
		return m.SessionTransferUrl
	}
	return ""
}

// CheckAccountPermissionRequest
type CheckAccountPermissionRequest struct {
	// The User ID.
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// The Account ID.
	AccountId string `protobuf:"bytes,2,opt,name=account_id,json=accountId" json:"account_id,omitempty"`
}

func (m *CheckAccountPermissionRequest) Reset()                    { *m = CheckAccountPermissionRequest{} }
func (m *CheckAccountPermissionRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckAccountPermissionRequest) ProtoMessage()               {}
func (*CheckAccountPermissionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CheckAccountPermissionRequest) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *CheckAccountPermissionRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

type ListActiveAddonsRequest struct {
	// The business id
	BusinessId string `protobuf:"bytes,1,opt,name=business_id,json=businessId" json:"business_id,omitempty"`
}

func (m *ListActiveAddonsRequest) Reset()                    { *m = ListActiveAddonsRequest{} }
func (m *ListActiveAddonsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListActiveAddonsRequest) ProtoMessage()               {}
func (*ListActiveAddonsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ListActiveAddonsRequest) GetBusinessId() string {
	if m != nil {
		return m.BusinessId
	}
	return ""
}

type AddonActivation struct {
	// A prerequisite marketplace vendor's ID's of the addon activated.
	AddonId string `protobuf:"bytes,1,opt,name=addon_id,json=addonId" json:"addon_id,omitempty"`
	// An ID assigned uniquely to this addon upon being activated.
	ActivationId string `protobuf:"bytes,2,opt,name=activation_id,json=activationId" json:"activation_id,omitempty"`
}

func (m *AddonActivation) Reset()                    { *m = AddonActivation{} }
func (m *AddonActivation) String() string            { return proto.CompactTextString(m) }
func (*AddonActivation) ProtoMessage()               {}
func (*AddonActivation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *AddonActivation) GetAddonId() string {
	if m != nil {
		return m.AddonId
	}
	return ""
}

func (m *AddonActivation) GetActivationId() string {
	if m != nil {
		return m.ActivationId
	}
	return ""
}

type ListActiveAddonsResponse struct {
	// The active addons for the specified business on the app.
	Addons []*AddonActivation `protobuf:"bytes,1,rep,name=addons" json:"addons,omitempty"`
}

func (m *ListActiveAddonsResponse) Reset()                    { *m = ListActiveAddonsResponse{} }
func (m *ListActiveAddonsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListActiveAddonsResponse) ProtoMessage()               {}
func (*ListActiveAddonsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ListActiveAddonsResponse) GetAddons() []*AddonActivation {
	if m != nil {
		return m.Addons
	}
	return nil
}

type ListAssociatedUsersRequest struct {
	// The business id
	BusinessId string `protobuf:"bytes,1,opt,name=business_id,json=businessId" json:"business_id,omitempty"`
}

func (m *ListAssociatedUsersRequest) Reset()                    { *m = ListAssociatedUsersRequest{} }
func (m *ListAssociatedUsersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListAssociatedUsersRequest) ProtoMessage()               {}
func (*ListAssociatedUsersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ListAssociatedUsersRequest) GetBusinessId() string {
	if m != nil {
		return m.BusinessId
	}
	return ""
}

type User struct {
	// Primary identifier for the user
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *User) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

type ListAssociatedUsersResponse struct {
	// Users associated with the specified business and application
	Users []*User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
}

func (m *ListAssociatedUsersResponse) Reset()                    { *m = ListAssociatedUsersResponse{} }
func (m *ListAssociatedUsersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListAssociatedUsersResponse) ProtoMessage()               {}
func (*ListAssociatedUsersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListAssociatedUsersResponse) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type GetSessionFromTokenRequest struct {
	// The encrypted authorization token
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *GetSessionFromTokenRequest) Reset()                    { *m = GetSessionFromTokenRequest{} }
func (m *GetSessionFromTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSessionFromTokenRequest) ProtoMessage()               {}
func (*GetSessionFromTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetSessionFromTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type Session struct {
	// The App ID from the session information
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	// The time that the token was first issued
	Issued *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=issued" json:"issued,omitempty"`
	// The time that the token is valid until
	Expires *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=expires" json:"expires,omitempty"`
}

func (m *Session) Reset()                    { *m = Session{} }
func (m *Session) String() string            { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()               {}
func (*Session) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Session) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *Session) GetIssued() *google_protobuf.Timestamp {
	if m != nil {
		return m.Issued
	}
	return nil
}

func (m *Session) GetExpires() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expires
	}
	return nil
}

type GetSessionFromTokenResponse struct {
	// The Session associated with the specified token
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *GetSessionFromTokenResponse) Reset()                    { *m = GetSessionFromTokenResponse{} }
func (m *GetSessionFromTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSessionFromTokenResponse) ProtoMessage()               {}
func (*GetSessionFromTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetSessionFromTokenResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func init() {
	proto.RegisterType((*GetOAuthTokenRequest)(nil), "marketplace.v1.GetOAuthTokenRequest")
	proto.RegisterType((*GetOAuthTokenResponse)(nil), "marketplace.v1.GetOAuthTokenResponse")
	proto.RegisterType((*GetSessionTransferURLRequest)(nil), "marketplace.v1.GetSessionTransferURLRequest")
	proto.RegisterType((*GetSessionTransferURLResponse)(nil), "marketplace.v1.GetSessionTransferURLResponse")
	proto.RegisterType((*CheckAccountPermissionRequest)(nil), "marketplace.v1.CheckAccountPermissionRequest")
	proto.RegisterType((*ListActiveAddonsRequest)(nil), "marketplace.v1.ListActiveAddonsRequest")
	proto.RegisterType((*AddonActivation)(nil), "marketplace.v1.AddonActivation")
	proto.RegisterType((*ListActiveAddonsResponse)(nil), "marketplace.v1.ListActiveAddonsResponse")
	proto.RegisterType((*ListAssociatedUsersRequest)(nil), "marketplace.v1.ListAssociatedUsersRequest")
	proto.RegisterType((*User)(nil), "marketplace.v1.User")
	proto.RegisterType((*ListAssociatedUsersResponse)(nil), "marketplace.v1.ListAssociatedUsersResponse")
	proto.RegisterType((*GetSessionFromTokenRequest)(nil), "marketplace.v1.GetSessionFromTokenRequest")
	proto.RegisterType((*Session)(nil), "marketplace.v1.Session")
	proto.RegisterType((*GetSessionFromTokenResponse)(nil), "marketplace.v1.GetSessionFromTokenResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Marketplace service

type MarketplaceClient interface {
	// GetOAuthToken is for requesting an oauth token for a marketplace application to use to authenticate against all
	// other RPC's/API's.
	GetOAuthToken(ctx context.Context, in *GetOAuthTokenRequest, opts ...grpc.CallOption) (*GetOAuthTokenResponse, error)
	// GetSessionTransferURLRequest is for requesting the session transfer URL for an account (account group).
	GetSessionTransferURL(ctx context.Context, in *GetSessionTransferURLRequest, opts ...grpc.CallOption) (*GetSessionTransferURLResponse, error)
	// CheckAccountPermission checks whether the given user has access to the given account (account group).
	CheckAccountPermission(ctx context.Context, in *CheckAccountPermissionRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// ListAssociatedUsers gives all the Users for specified business.
	ListAssociatedUsers(ctx context.Context, in *ListAssociatedUsersRequest, opts ...grpc.CallOption) (*ListAssociatedUsersResponse, error)
	// ListActiveAddons gives all the addons the specified business has active on the specified application.
	ListActiveAddons(ctx context.Context, in *ListActiveAddonsRequest, opts ...grpc.CallOption) (*ListActiveAddonsResponse, error)
	// GetSessionFromToken is for requesting the session information from a token
	GetSessionFromToken(ctx context.Context, in *GetSessionFromTokenRequest, opts ...grpc.CallOption) (*GetSessionFromTokenResponse, error)
}

type marketplaceClient struct {
	cc *grpc.ClientConn
}

func NewMarketplaceClient(cc *grpc.ClientConn) MarketplaceClient {
	return &marketplaceClient{cc}
}

func (c *marketplaceClient) GetOAuthToken(ctx context.Context, in *GetOAuthTokenRequest, opts ...grpc.CallOption) (*GetOAuthTokenResponse, error) {
	out := new(GetOAuthTokenResponse)
	err := grpc.Invoke(ctx, "/marketplace.v1.Marketplace/GetOAuthToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketplaceClient) GetSessionTransferURL(ctx context.Context, in *GetSessionTransferURLRequest, opts ...grpc.CallOption) (*GetSessionTransferURLResponse, error) {
	out := new(GetSessionTransferURLResponse)
	err := grpc.Invoke(ctx, "/marketplace.v1.Marketplace/GetSessionTransferURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketplaceClient) CheckAccountPermission(ctx context.Context, in *CheckAccountPermissionRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/marketplace.v1.Marketplace/CheckAccountPermission", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketplaceClient) ListAssociatedUsers(ctx context.Context, in *ListAssociatedUsersRequest, opts ...grpc.CallOption) (*ListAssociatedUsersResponse, error) {
	out := new(ListAssociatedUsersResponse)
	err := grpc.Invoke(ctx, "/marketplace.v1.Marketplace/ListAssociatedUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketplaceClient) ListActiveAddons(ctx context.Context, in *ListActiveAddonsRequest, opts ...grpc.CallOption) (*ListActiveAddonsResponse, error) {
	out := new(ListActiveAddonsResponse)
	err := grpc.Invoke(ctx, "/marketplace.v1.Marketplace/ListActiveAddons", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketplaceClient) GetSessionFromToken(ctx context.Context, in *GetSessionFromTokenRequest, opts ...grpc.CallOption) (*GetSessionFromTokenResponse, error) {
	out := new(GetSessionFromTokenResponse)
	err := grpc.Invoke(ctx, "/marketplace.v1.Marketplace/GetSessionFromToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Marketplace service

type MarketplaceServer interface {
	// GetOAuthToken is for requesting an oauth token for a marketplace application to use to authenticate against all
	// other RPC's/API's.
	GetOAuthToken(context.Context, *GetOAuthTokenRequest) (*GetOAuthTokenResponse, error)
	// GetSessionTransferURLRequest is for requesting the session transfer URL for an account (account group).
	GetSessionTransferURL(context.Context, *GetSessionTransferURLRequest) (*GetSessionTransferURLResponse, error)
	// CheckAccountPermission checks whether the given user has access to the given account (account group).
	CheckAccountPermission(context.Context, *CheckAccountPermissionRequest) (*google_protobuf1.Empty, error)
	// ListAssociatedUsers gives all the Users for specified business.
	ListAssociatedUsers(context.Context, *ListAssociatedUsersRequest) (*ListAssociatedUsersResponse, error)
	// ListActiveAddons gives all the addons the specified business has active on the specified application.
	ListActiveAddons(context.Context, *ListActiveAddonsRequest) (*ListActiveAddonsResponse, error)
	// GetSessionFromToken is for requesting the session information from a token
	GetSessionFromToken(context.Context, *GetSessionFromTokenRequest) (*GetSessionFromTokenResponse, error)
}

func RegisterMarketplaceServer(s *grpc.Server, srv MarketplaceServer) {
	s.RegisterService(&_Marketplace_serviceDesc, srv)
}

func _Marketplace_GetOAuthToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOAuthTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketplaceServer).GetOAuthToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marketplace.v1.Marketplace/GetOAuthToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketplaceServer).GetOAuthToken(ctx, req.(*GetOAuthTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marketplace_GetSessionTransferURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionTransferURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketplaceServer).GetSessionTransferURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marketplace.v1.Marketplace/GetSessionTransferURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketplaceServer).GetSessionTransferURL(ctx, req.(*GetSessionTransferURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marketplace_CheckAccountPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAccountPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketplaceServer).CheckAccountPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marketplace.v1.Marketplace/CheckAccountPermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketplaceServer).CheckAccountPermission(ctx, req.(*CheckAccountPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marketplace_ListAssociatedUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAssociatedUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketplaceServer).ListAssociatedUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marketplace.v1.Marketplace/ListAssociatedUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketplaceServer).ListAssociatedUsers(ctx, req.(*ListAssociatedUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marketplace_ListActiveAddons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActiveAddonsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketplaceServer).ListActiveAddons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marketplace.v1.Marketplace/ListActiveAddons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketplaceServer).ListActiveAddons(ctx, req.(*ListActiveAddonsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marketplace_GetSessionFromToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionFromTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketplaceServer).GetSessionFromToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marketplace.v1.Marketplace/GetSessionFromToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketplaceServer).GetSessionFromToken(ctx, req.(*GetSessionFromTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Marketplace_serviceDesc = grpc.ServiceDesc{
	ServiceName: "marketplace.v1.Marketplace",
	HandlerType: (*MarketplaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOAuthToken",
			Handler:    _Marketplace_GetOAuthToken_Handler,
		},
		{
			MethodName: "GetSessionTransferURL",
			Handler:    _Marketplace_GetSessionTransferURL_Handler,
		},
		{
			MethodName: "CheckAccountPermission",
			Handler:    _Marketplace_CheckAccountPermission_Handler,
		},
		{
			MethodName: "ListAssociatedUsers",
			Handler:    _Marketplace_ListAssociatedUsers_Handler,
		},
		{
			MethodName: "ListActiveAddons",
			Handler:    _Marketplace_ListActiveAddons_Handler,
		},
		{
			MethodName: "GetSessionFromToken",
			Handler:    _Marketplace_GetSessionFromToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "marketplace/v1/api.proto",
}

func init() { proto.RegisterFile("marketplace/v1/api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 678 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x54, 0x51, 0x4f, 0xd3, 0x50,
	0x14, 0x66, 0xe0, 0x36, 0x39, 0x03, 0x35, 0x97, 0x01, 0xb3, 0x40, 0x86, 0x55, 0xe3, 0x82, 0xda,
	0xc9, 0x34, 0x31, 0x31, 0xe1, 0x61, 0x31, 0x4a, 0x96, 0x60, 0xc4, 0x32, 0xe2, 0x9b, 0xcb, 0xa5,
	0x3d, 0x8c, 0x86, 0xad, 0xbd, 0xde, 0x7b, 0xbb, 0xc8, 0x5f, 0xf0, 0xc5, 0x27, 0xff, 0xaf, 0xe9,
	0xed, 0xed, 0x0a, 0x6d, 0x07, 0x8b, 0x8f, 0x3d, 0xe7, 0x3b, 0xdf, 0xfd, 0xbe, 0xd3, 0x73, 0x0e,
	0x34, 0xc6, 0x94, 0x5f, 0xa2, 0x64, 0x23, 0xea, 0x60, 0x7b, 0xb2, 0xdf, 0xa6, 0xcc, 0xb3, 0x18,
	0x0f, 0x64, 0x40, 0x1e, 0x5c, 0xcb, 0x58, 0x93, 0x7d, 0xa3, 0x39, 0x0c, 0x82, 0xe1, 0x08, 0xdb,
	0x2a, 0x7b, 0x16, 0x9e, 0xb7, 0xa5, 0x37, 0x46, 0x21, 0xe9, 0x98, 0xc5, 0x05, 0xc6, 0x56, 0x16,
	0x80, 0x63, 0x26, 0xaf, 0xe2, 0xa4, 0x79, 0x02, 0xf5, 0x43, 0x94, 0x5f, 0xbb, 0xa1, 0xbc, 0xe8,
	0x07, 0x97, 0xe8, 0xdb, 0xf8, 0x33, 0x44, 0x21, 0xc9, 0x0e, 0xc0, 0x90, 0x53, 0x5f, 0x0e, 0xe4,
	0x15, 0xc3, 0x46, 0x69, 0xb7, 0xd4, 0x5a, 0xb6, 0x97, 0x55, 0xa4, 0x7f, 0xc5, 0x90, 0x6c, 0xc3,
	0x32, 0x15, 0x02, 0xb9, 0xf4, 0x02, 0xbf, 0xb1, 0x18, 0x67, 0xa7, 0x01, 0xf3, 0x4f, 0x09, 0xd6,
	0x33, 0xac, 0x82, 0x05, 0xbe, 0x40, 0xf2, 0x04, 0x56, 0xa8, 0xe3, 0xa0, 0x10, 0x03, 0x19, 0xc5,
	0x35, 0x71, 0x2d, 0x8e, 0x29, 0x68, 0xf4, 0xb2, 0xca, 0xc5, 0x2f, 0x6b, 0x6e, 0x15, 0x51, 0x2f,
	0xbf, 0x83, 0x2a, 0xfe, 0x62, 0x1e, 0x47, 0xd1, 0x58, 0xda, 0x2d, 0xb5, 0x6a, 0x1d, 0xc3, 0x8a,
	0xfd, 0x59, 0x89, 0x3f, 0xab, 0x9f, 0x34, 0xc0, 0x4e, 0xa0, 0xe6, 0x01, 0x6c, 0x1f, 0xa2, 0x3c,
	0x41, 0x21, 0xbc, 0xc0, 0xef, 0x73, 0xea, 0x8b, 0x73, 0xe4, 0xa7, 0xf6, 0xd1, 0x35, 0xbb, 0xd4,
	0x71, 0x82, 0xd0, 0x97, 0x03, 0xcf, 0x4d, 0xec, 0xea, 0x48, 0xcf, 0x35, 0xbf, 0xc1, 0xce, 0x8c,
	0x72, 0xed, 0xeb, 0x0d, 0xd4, 0x45, 0x9c, 0x1d, 0x48, 0x9d, 0x1e, 0x84, 0x7c, 0xa4, 0x99, 0x88,
	0xc8, 0x54, 0xf2, 0x91, 0xf9, 0x1d, 0x76, 0x3e, 0x5e, 0xa0, 0x73, 0xd9, 0x8d, 0x1f, 0x39, 0x46,
	0x3e, 0xf6, 0x14, 0x28, 0x91, 0xb4, 0x09, 0xd5, 0x50, 0x20, 0x4f, 0xf5, 0x54, 0xa2, 0xcf, 0x9e,
	0x9b, 0xd1, 0xba, 0x98, 0xd5, 0xfa, 0x01, 0x36, 0x8f, 0x3c, 0x21, 0xbb, 0x8e, 0xf4, 0x26, 0xd8,
	0x75, 0xdd, 0xc0, 0x17, 0x09, 0x65, 0x13, 0x6a, 0x67, 0xa1, 0xf0, 0xfc, 0xa8, 0xff, 0x53, 0x5a,
	0x48, 0x42, 0xca, 0xe7, 0x43, 0x55, 0xa1, 0x8a, 0x69, 0xf4, 0x2f, 0xc9, 0x63, 0xb8, 0x4f, 0xa3,
	0x50, 0x5a, 0x50, 0x55, 0xdf, 0x3d, 0x97, 0x3c, 0x85, 0x55, 0x3a, 0x05, 0xa6, 0x5a, 0x56, 0xd2,
	0x60, 0xcf, 0x35, 0x4f, 0xa0, 0x91, 0x97, 0xa3, 0xbb, 0xf6, 0x1e, 0x2a, 0x8a, 0x4b, 0x34, 0x4a,
	0xbb, 0x4b, 0xad, 0x5a, 0xa7, 0x69, 0xdd, 0x9c, 0x6d, 0x2b, 0x23, 0xc6, 0xd6, 0x70, 0xf3, 0x00,
	0x0c, 0x45, 0x2a, 0x44, 0xe0, 0x78, 0x54, 0xa2, 0x7b, 0x2a, 0x90, 0xcf, 0x6f, 0xb3, 0x09, 0xf7,
	0xa2, 0x82, 0x99, 0x2d, 0x36, 0x7b, 0xb0, 0x55, 0xc8, 0xaf, 0x75, 0xef, 0x41, 0x39, 0x02, 0x26,
	0xb2, 0xeb, 0x59, 0xd9, 0x11, 0xda, 0x8e, 0x21, 0x66, 0x07, 0x8c, 0x74, 0x74, 0x3e, 0xf3, 0x60,
	0x7c, 0x63, 0xcd, 0xea, 0x50, 0xbe, 0xbe, 0x08, 0xf1, 0x87, 0xf9, 0xbb, 0x04, 0x55, 0x5d, 0x41,
	0xd6, 0xa1, 0x42, 0x19, 0x4b, 0x25, 0x96, 0x29, 0x63, 0x3d, 0x97, 0x74, 0xa0, 0xe2, 0x09, 0x11,
	0x62, 0xdc, 0xf4, 0xdb, 0xb7, 0x40, 0x23, 0xff, 0x73, 0x75, 0x8e, 0x61, 0xab, 0xd0, 0x80, 0xee,
	0xc5, 0x3e, 0x54, 0xf5, 0x74, 0x2b, 0x81, 0xb5, 0xce, 0x66, 0xb6, 0x1b, 0xba, 0xd4, 0x4e, 0x70,
	0x9d, 0xbf, 0x65, 0xa8, 0x7d, 0x49, 0x31, 0xe4, 0x07, 0xac, 0xde, 0xb8, 0x16, 0xe4, 0x59, 0x96,
	0xa2, 0xe8, 0x44, 0x19, 0xcf, 0xef, 0x40, 0xc5, 0x02, 0xcd, 0x05, 0x32, 0x51, 0xd7, 0x28, 0xbf,
	0xbd, 0xe4, 0x55, 0x01, 0xc3, 0xcc, 0x1b, 0x61, 0xbc, 0x9e, 0x13, 0x3d, 0x7d, 0x97, 0xc2, 0x46,
	0xf1, 0x8a, 0x93, 0x1c, 0xd5, 0xad, 0xa7, 0xc0, 0xd8, 0xc8, 0xfd, 0xa7, 0x4f, 0xd1, 0x09, 0x37,
	0x17, 0x08, 0x83, 0xb5, 0x82, 0x41, 0x25, 0x7b, 0x59, 0xfe, 0xd9, 0xdb, 0x62, 0xbc, 0x9c, 0x0b,
	0x3b, 0x35, 0x35, 0x84, 0x47, 0xd9, 0x7d, 0x26, 0x2f, 0x0a, 0x29, 0xf2, 0x07, 0xc8, 0x68, 0xdd,
	0x0d, 0x9c, 0x3e, 0xc4, 0x60, 0xad, 0x60, 0xee, 0xf2, 0xd6, 0x66, 0x6f, 0x57, 0xde, 0xda, 0x2d,
	0x83, 0x6c, 0x2e, 0x9c, 0x55, 0x54, 0x7b, 0xdf, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xd2, 0x13,
	0xb4, 0x19, 0x7c, 0x07, 0x00, 0x00,
}
