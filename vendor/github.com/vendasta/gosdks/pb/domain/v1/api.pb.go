// Code generated by protoc-gen-go.
// source: api.proto
// DO NOT EDIT!

/*
Package domain_v1 is a generated protocol buffer package.

It is generated from these files:
	api.proto
	dns_record.proto

It has these top-level messages:
	GetDNSRecordsRequest
	GetDNSRecordsResponse
	Identifier
	Domain
	GetIdentifierByDomainRequest
	GetIdentifierByDomainResponse
	GetDomainByIdentifierRequest
	GetDomainByIdentifierResponse
	ARecord
	CNameRecord
	CAAValue
	CAARecord
*/
package domain_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A request for getting a domain's DNS records
type GetDNSRecordsRequest struct {
	// The domain for which to get DNS records
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// The record types for which to check
	RecordTypes []DNSRecordType `protobuf:"varint,2,rep,packed,name=record_types,json=recordTypes,enum=domain.v1.DNSRecordType" json:"record_types,omitempty"`
}

func (m *GetDNSRecordsRequest) Reset()                    { *m = GetDNSRecordsRequest{} }
func (m *GetDNSRecordsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDNSRecordsRequest) ProtoMessage()               {}
func (*GetDNSRecordsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GetDNSRecordsRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *GetDNSRecordsRequest) GetRecordTypes() []DNSRecordType {
	if m != nil {
		return m.RecordTypes
	}
	return nil
}

// A response that represents a donmain's DNS records
type GetDNSRecordsResponse struct {
	// The domain that has dns records below
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// DNS A record for the domain above
	ARecord *ARecord `protobuf:"bytes,2,opt,name=a_record,json=aRecord" json:"a_record,omitempty"`
	// DNS Cname record for the domain above
	CnameRecord *CNameRecord `protobuf:"bytes,3,opt,name=cname_record,json=cnameRecord" json:"cname_record,omitempty"`
	// DNS CAA record for the domain above
	CaaRecord *CAARecord `protobuf:"bytes,4,opt,name=caa_record,json=caaRecord" json:"caa_record,omitempty"`
}

func (m *GetDNSRecordsResponse) Reset()                    { *m = GetDNSRecordsResponse{} }
func (m *GetDNSRecordsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDNSRecordsResponse) ProtoMessage()               {}
func (*GetDNSRecordsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetDNSRecordsResponse) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *GetDNSRecordsResponse) GetARecord() *ARecord {
	if m != nil {
		return m.ARecord
	}
	return nil
}

func (m *GetDNSRecordsResponse) GetCnameRecord() *CNameRecord {
	if m != nil {
		return m.CnameRecord
	}
	return nil
}

func (m *GetDNSRecordsResponse) GetCaaRecord() *CAARecord {
	if m != nil {
		return m.CaaRecord
	}
	return nil
}

// Identifier is a contextual id that holds hierarchical data.
//
// Examples:
//
// Identifier{contextual_identifier: "/application/partner-center"}
// Identifier{contextual_identifier: "/product/RM/partner/ABC"}
// Identifier{contextual_identifier: "/product/SM/partner/DEF/market/my-market"}
// Identifier{contextual_identifier: "/marketplace/website-pro/account/AG-J7V5H8AV/website/49da31ebc3f34f6c97dd540e2447dca7"}
//
// These hierarchical identifiers allow for flexible re-use, as well as scanning across each contextual piece.
// For example, you could scan across all domains for `/product/RM`, which returns all custom domains for Reputation Intelligence.
// You could also scan across `/product/SM/partner/DEF` and get all of the custom market domains for the DEF partner in SM.
type Identifier struct {
	ContextualIdentifier string `protobuf:"bytes,1,opt,name=contextual_identifier,json=contextualIdentifier" json:"contextual_identifier,omitempty"`
}

func (m *Identifier) Reset()                    { *m = Identifier{} }
func (m *Identifier) String() string            { return proto.CompactTextString(m) }
func (*Identifier) ProtoMessage()               {}
func (*Identifier) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Identifier) GetContextualIdentifier() string {
	if m != nil {
		return m.ContextualIdentifier
	}
	return ""
}

// Provides the domain name and additional metadata.
type Domain struct {
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	Secure bool   `protobuf:"varint,2,opt,name=secure" json:"secure,omitempty"`
}

func (m *Domain) Reset()                    { *m = Domain{} }
func (m *Domain) String() string            { return proto.CompactTextString(m) }
func (*Domain) ProtoMessage()               {}
func (*Domain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Domain) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Domain) GetSecure() bool {
	if m != nil {
		return m.Secure
	}
	return false
}

// A request for getting an Identifier by a domain.
type GetIdentifierByDomainRequest struct {
	//  The domain or sub-domain name.
	// Examples:
	//  - partners.vendasta.com
	//  - steprep-prod-hrd.appspot.com
	//  - rep.customdomain.com
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
}

func (m *GetIdentifierByDomainRequest) Reset()                    { *m = GetIdentifierByDomainRequest{} }
func (m *GetIdentifierByDomainRequest) String() string            { return proto.CompactTextString(m) }
func (*GetIdentifierByDomainRequest) ProtoMessage()               {}
func (*GetIdentifierByDomainRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetIdentifierByDomainRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

// Response for GetIdentifierByDomain
type GetIdentifierByDomainResponse struct {
	Identifier *Identifier `protobuf:"bytes,1,opt,name=identifier" json:"identifier,omitempty"`
}

func (m *GetIdentifierByDomainResponse) Reset()                    { *m = GetIdentifierByDomainResponse{} }
func (m *GetIdentifierByDomainResponse) String() string            { return proto.CompactTextString(m) }
func (*GetIdentifierByDomainResponse) ProtoMessage()               {}
func (*GetIdentifierByDomainResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetIdentifierByDomainResponse) GetIdentifier() *Identifier {
	if m != nil {
		return m.Identifier
	}
	return nil
}

// A request for getting a domain by an Identifier.
type GetDomainByIdentifierRequest struct {
	Identifier *Identifier `protobuf:"bytes,1,opt,name=identifier" json:"identifier,omitempty"`
}

func (m *GetDomainByIdentifierRequest) Reset()                    { *m = GetDomainByIdentifierRequest{} }
func (m *GetDomainByIdentifierRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDomainByIdentifierRequest) ProtoMessage()               {}
func (*GetDomainByIdentifierRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetDomainByIdentifierRequest) GetIdentifier() *Identifier {
	if m != nil {
		return m.Identifier
	}
	return nil
}

// Response for GetDomainByIdentifier
type GetDomainByIdentifierResponse struct {
	Primary     *Domain   `protobuf:"bytes,1,opt,name=primary" json:"primary,omitempty"`
	Secondaries []*Domain `protobuf:"bytes,2,rep,name=secondaries" json:"secondaries,omitempty"`
}

func (m *GetDomainByIdentifierResponse) Reset()                    { *m = GetDomainByIdentifierResponse{} }
func (m *GetDomainByIdentifierResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDomainByIdentifierResponse) ProtoMessage()               {}
func (*GetDomainByIdentifierResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetDomainByIdentifierResponse) GetPrimary() *Domain {
	if m != nil {
		return m.Primary
	}
	return nil
}

func (m *GetDomainByIdentifierResponse) GetSecondaries() []*Domain {
	if m != nil {
		return m.Secondaries
	}
	return nil
}

func init() {
	proto.RegisterType((*GetDNSRecordsRequest)(nil), "domain.v1.GetDNSRecordsRequest")
	proto.RegisterType((*GetDNSRecordsResponse)(nil), "domain.v1.GetDNSRecordsResponse")
	proto.RegisterType((*Identifier)(nil), "domain.v1.Identifier")
	proto.RegisterType((*Domain)(nil), "domain.v1.Domain")
	proto.RegisterType((*GetIdentifierByDomainRequest)(nil), "domain.v1.GetIdentifierByDomainRequest")
	proto.RegisterType((*GetIdentifierByDomainResponse)(nil), "domain.v1.GetIdentifierByDomainResponse")
	proto.RegisterType((*GetDomainByIdentifierRequest)(nil), "domain.v1.GetDomainByIdentifierRequest")
	proto.RegisterType((*GetDomainByIdentifierResponse)(nil), "domain.v1.GetDomainByIdentifierResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DomainService service

type DomainServiceClient interface {
	// contract: returns a gRPC 7 if caller is unauthorized to access domain micro service
	// Get a domain's DNS records by given domain
	GetDNSRecords(ctx context.Context, in *GetDNSRecordsRequest, opts ...grpc.CallOption) (*GetDNSRecordsResponse, error)
	// Returns an identifier of the owner of the given domain if it exists
	GetIdentifierByDomain(ctx context.Context, in *GetIdentifierByDomainRequest, opts ...grpc.CallOption) (*GetIdentifierByDomainResponse, error)
	// Returns a domain by the Identifier if it exists.
	GetDomainByIdentifier(ctx context.Context, in *GetDomainByIdentifierRequest, opts ...grpc.CallOption) (*GetDomainByIdentifierResponse, error)
}

type domainServiceClient struct {
	cc *grpc.ClientConn
}

func NewDomainServiceClient(cc *grpc.ClientConn) DomainServiceClient {
	return &domainServiceClient{cc}
}

func (c *domainServiceClient) GetDNSRecords(ctx context.Context, in *GetDNSRecordsRequest, opts ...grpc.CallOption) (*GetDNSRecordsResponse, error) {
	out := new(GetDNSRecordsResponse)
	err := grpc.Invoke(ctx, "/domain.v1.DomainService/GetDNSRecords", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *domainServiceClient) GetIdentifierByDomain(ctx context.Context, in *GetIdentifierByDomainRequest, opts ...grpc.CallOption) (*GetIdentifierByDomainResponse, error) {
	out := new(GetIdentifierByDomainResponse)
	err := grpc.Invoke(ctx, "/domain.v1.DomainService/GetIdentifierByDomain", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *domainServiceClient) GetDomainByIdentifier(ctx context.Context, in *GetDomainByIdentifierRequest, opts ...grpc.CallOption) (*GetDomainByIdentifierResponse, error) {
	out := new(GetDomainByIdentifierResponse)
	err := grpc.Invoke(ctx, "/domain.v1.DomainService/GetDomainByIdentifier", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DomainService service

type DomainServiceServer interface {
	// contract: returns a gRPC 7 if caller is unauthorized to access domain micro service
	// Get a domain's DNS records by given domain
	GetDNSRecords(context.Context, *GetDNSRecordsRequest) (*GetDNSRecordsResponse, error)
	// Returns an identifier of the owner of the given domain if it exists
	GetIdentifierByDomain(context.Context, *GetIdentifierByDomainRequest) (*GetIdentifierByDomainResponse, error)
	// Returns a domain by the Identifier if it exists.
	GetDomainByIdentifier(context.Context, *GetDomainByIdentifierRequest) (*GetDomainByIdentifierResponse, error)
}

func RegisterDomainServiceServer(s *grpc.Server, srv DomainServiceServer) {
	s.RegisterService(&_DomainService_serviceDesc, srv)
}

func _DomainService_GetDNSRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDNSRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DomainServiceServer).GetDNSRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.v1.DomainService/GetDNSRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DomainServiceServer).GetDNSRecords(ctx, req.(*GetDNSRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DomainService_GetIdentifierByDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIdentifierByDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DomainServiceServer).GetIdentifierByDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.v1.DomainService/GetIdentifierByDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DomainServiceServer).GetIdentifierByDomain(ctx, req.(*GetIdentifierByDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DomainService_GetDomainByIdentifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDomainByIdentifierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DomainServiceServer).GetDomainByIdentifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.v1.DomainService/GetDomainByIdentifier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DomainServiceServer).GetDomainByIdentifier(ctx, req.(*GetDomainByIdentifierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DomainService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "domain.v1.DomainService",
	HandlerType: (*DomainServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDNSRecords",
			Handler:    _DomainService_GetDNSRecords_Handler,
		},
		{
			MethodName: "GetIdentifierByDomain",
			Handler:    _DomainService_GetIdentifierByDomain_Handler,
		},
		{
			MethodName: "GetDomainByIdentifier",
			Handler:    _DomainService_GetDomainByIdentifier_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 445 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x94, 0x4d, 0x6f, 0xd3, 0x30,
	0x18, 0xc7, 0x97, 0x0e, 0x75, 0xeb, 0x93, 0x0d, 0x81, 0xd5, 0x56, 0x55, 0x05, 0xa2, 0xf2, 0x85,
	0x48, 0x88, 0x48, 0x24, 0x02, 0x81, 0x38, 0x75, 0x4c, 0x9a, 0xb8, 0xec, 0x90, 0x0d, 0xae, 0x95,
	0x71, 0x1e, 0x24, 0x8b, 0xe5, 0x05, 0xdb, 0x9d, 0xc8, 0x91, 0x8f, 0xc6, 0x17, 0xe0, 0x33, 0x21,
	0xd9, 0x6e, 0xe2, 0x65, 0x8d, 0x26, 0x71, 0x8b, 0xed, 0xe7, 0xf7, 0xff, 0x3f, 0x2f, 0x76, 0x60,
	0xc2, 0x6a, 0x11, 0xd7, 0xb2, 0xd2, 0x15, 0x99, 0xe4, 0x55, 0xc1, 0x44, 0x19, 0xdf, 0xbe, 0x59,
	0x3e, 0xc9, 0x4b, 0xb5, 0x91, 0xc8, 0x2b, 0x99, 0xdb, 0x43, 0xfa, 0x03, 0xa6, 0x17, 0xa8, 0xcf,
	0x2f, 0xaf, 0x32, 0xb3, 0xab, 0x32, 0xfc, 0xb9, 0x45, 0xa5, 0xc9, 0x1c, 0xc6, 0x16, 0x5b, 0x04,
	0xab, 0x20, 0x9a, 0x64, 0x6e, 0x45, 0x3e, 0xc2, 0x89, 0xe5, 0x37, 0xba, 0xa9, 0x51, 0x2d, 0x46,
	0xab, 0xc3, 0xe8, 0x71, 0xb2, 0x88, 0x5b, 0x8f, 0xb8, 0xd5, 0xba, 0x6e, 0x6a, 0xcc, 0x42, 0xd9,
	0x7e, 0x2b, 0xfa, 0x37, 0x80, 0x59, 0xcf, 0x4d, 0xd5, 0x55, 0xa9, 0x70, 0xd0, 0xee, 0x35, 0x1c,
	0x33, 0x97, 0xf0, 0x62, 0xb4, 0x0a, 0xa2, 0x30, 0x21, 0x9e, 0xd5, 0xda, 0xca, 0x64, 0x47, 0xcc,
	0x7e, 0x90, 0x0f, 0x70, 0xc2, 0x4b, 0x56, 0xe0, 0x0e, 0x39, 0x34, 0xc8, 0xdc, 0x43, 0x3e, 0x5d,
	0xb2, 0x02, 0x1d, 0x16, 0x9a, 0x58, 0x87, 0xa6, 0x00, 0x9c, 0xb5, 0x5e, 0x8f, 0x0c, 0x38, 0xf5,
	0xc1, 0xf5, 0xce, 0x6d, 0xc2, 0x99, 0xf3, 0xa3, 0x6b, 0x80, 0xcf, 0x39, 0x96, 0x5a, 0x7c, 0x17,
	0x28, 0x49, 0x0a, 0x33, 0x5e, 0x95, 0x1a, 0x7f, 0xe9, 0x2d, 0xbb, 0xd9, 0x88, 0xf6, 0xc0, 0xd5,
	0x34, 0xed, 0x0e, 0x3b, 0x88, 0xbe, 0x87, 0xf1, 0xb9, 0xad, 0x75, 0xa8, 0x07, 0x73, 0x18, 0x2b,
	0xe4, 0x5b, 0x89, 0xa6, 0x03, 0xc7, 0x99, 0x5b, 0xd1, 0x77, 0xf0, 0xec, 0x02, 0x75, 0x27, 0x75,
	0xd6, 0x58, 0xa1, 0x07, 0x46, 0x48, 0xbf, 0xc2, 0xf3, 0x01, 0xce, 0x0d, 0xe3, 0x2d, 0x40, 0x2f,
	0xf9, 0x30, 0x99, 0x79, 0xad, 0xe8, 0xd0, 0xcc, 0x0b, 0xa4, 0x5f, 0x4c, 0x3e, 0x56, 0xeb, 0xac,
	0xf1, 0x82, 0x5c, 0x3e, 0xff, 0x29, 0xfb, 0x3b, 0x30, 0xf9, 0xee, 0xd3, 0x75, 0xf9, 0xbe, 0x82,
	0xa3, 0x5a, 0x8a, 0x82, 0xc9, 0xc6, 0xa9, 0x3e, 0xf5, 0xaf, 0xa3, 0xad, 0x6d, 0x17, 0x41, 0x52,
	0x08, 0x15, 0xf2, 0xaa, 0xcc, 0x99, 0x14, 0xee, 0xfe, 0xee, 0x05, 0xfc, 0xa8, 0xe4, 0xcf, 0x08,
	0x4e, 0xed, 0xfe, 0x15, 0xca, 0x5b, 0xc1, 0x91, 0x5c, 0xc3, 0xe9, 0x9d, 0x9b, 0x4c, 0x5e, 0x78,
	0x12, 0xfb, 0x5e, 0xd4, 0x72, 0x35, 0x1c, 0x60, 0xeb, 0xa0, 0x07, 0xe4, 0xc6, 0xbc, 0x8f, 0xfb,
	0xa3, 0x21, 0x2f, 0xef, 0xc2, 0x83, 0x43, 0x5f, 0x46, 0x0f, 0x07, 0xf6, 0xdc, 0xee, 0x37, 0xb6,
	0xef, 0x36, 0x38, 0xd2, 0xbe, 0xdb, 0xf0, 0x8c, 0xe8, 0xc1, 0xb7, 0xb1, 0xf9, 0xe1, 0xa4, 0xff,
	0x02, 0x00, 0x00, 0xff, 0xff, 0xa1, 0x57, 0x91, 0xdf, 0x9a, 0x04, 0x00, 0x00,
}
