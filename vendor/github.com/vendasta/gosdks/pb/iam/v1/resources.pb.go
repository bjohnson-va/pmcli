// Code generated by protoc-gen-go. DO NOT EDIT.
// source: iam/v1/resources.proto

package iam_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// AccessScope represents the spectrum of intents that a resource may be accessed with. Different intents may entail the evaluation
// of different policies, as policies are associated not only to resources, but to specific AccessScope within the scope of that resource.
type AccessScope int32

const (
	AccessScope_READ   AccessScope = 0
	AccessScope_WRITE  AccessScope = 1
	AccessScope_DELETE AccessScope = 2
	AccessScope_LIST   AccessScope = 3
)

var AccessScope_name = map[int32]string{
	0: "READ",
	1: "WRITE",
	2: "DELETE",
	3: "LIST",
}
var AccessScope_value = map[string]int32{
	"READ":   0,
	"WRITE":  1,
	"DELETE": 2,
	"LIST":   3,
}

func (x AccessScope) String() string {
	return proto.EnumName(AccessScope_name, int32(x))
}
func (AccessScope) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

// ForOperator defines how the SubjectResourceFor clauses will evaluate the list of StructAttributes
type ForOperator int32

const (
	// ANY struct inside of the list must match the PolicyNode to be true
	ForOperator_ANY ForOperator = 0
	// ALL structs inside of the list must match the PolicyNode to be true
	ForOperator_ALL ForOperator = 1
)

var ForOperator_name = map[int32]string{
	0: "ANY",
	1: "ALL",
}
var ForOperator_value = map[string]int32{
	"ANY": 0,
	"ALL": 1,
}

func (x ForOperator) String() string {
	return proto.EnumName(ForOperator_name, int32(x))
}
func (ForOperator) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

// Boolean operator supports the basic boolean expressions AND, OR, NOT
type BooleanOperator int32

const (
	BooleanOperator_AND BooleanOperator = 0
	BooleanOperator_OR  BooleanOperator = 1
	BooleanOperator_NOT BooleanOperator = 2
)

var BooleanOperator_name = map[int32]string{
	0: "AND",
	1: "OR",
	2: "NOT",
}
var BooleanOperator_value = map[string]int32{
	"AND": 0,
	"OR":  1,
	"NOT": 2,
}

func (x BooleanOperator) String() string {
	return proto.EnumName(BooleanOperator_name, int32(x))
}
func (BooleanOperator) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

// ResourceOwner is an application that owns one or many distinct resources.
type ResourceOwner struct {
	// app_id is a unique identifier for the registrant. It must be unique across all IAM resource owners. (eg "VBC")
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	// app_name is the human readable name of the application registering as a Resource Owner (eg "Vendasta Business Center")
	AppName string `protobuf:"bytes,2,opt,name=app_name,json=appName" json:"app_name,omitempty"`
}

func (m *ResourceOwner) Reset()                    { *m = ResourceOwner{} }
func (m *ResourceOwner) String() string            { return proto.CompactTextString(m) }
func (*ResourceOwner) ProtoMessage()               {}
func (*ResourceOwner) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *ResourceOwner) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *ResourceOwner) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

// RegisterResourceRequest is issued by a ResourceOwner to tell IAM that they would like to expose a resource that IAM will control access to.
type RegisterResourceRequest struct {
	// app_id is a unique identifier for the ResourceOwner. It must be unique across all IAM resource owners. (eg "VBC")
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	// resource_id is an identifier for the resource that is unique within the resource owner's set of resources.
	ResourceId string `protobuf:"bytes,2,opt,name=resource_id,json=resourceId" json:"resource_id,omitempty"`
	// resource_name is the human readable name of the resource (eg "Account Group")
	ResourceName string `protobuf:"bytes,3,opt,name=resource_name,json=resourceName" json:"resource_name,omitempty"`
	// resource_owner_service_url is the base url where a ResourceOwner grpc service is being served. IAM will use this service to ask about specific resources
	ResourceOwnerServiceUrl string `protobuf:"bytes,4,opt,name=resource_owner_service_url,json=resourceOwnerServiceUrl" json:"resource_owner_service_url,omitempty"`
	// required_resource_params is the set of identifiers that must be provided to ask the resource provider about a resource from
	// IAM's point of view. These parameters will need to be supplied by any client asking about this resource.
	// eg: ["pid", "account_group_id"] means that each time IAM asks for one of these resources, it will require the client to specify
	// which "pid" and "account_group_id" they are asking about. IAM will proxy these parameters to the resource_owner_service_url.
	RequiredResourceParams []string `protobuf:"bytes,5,rep,name=required_resource_params,json=requiredResourceParams" json:"required_resource_params,omitempty"`
	// resource_owner_audience is a google id token audience. This is used by the resource owner to validate requests.
	ResourceOwnerAudience string `protobuf:"bytes,6,opt,name=resource_owner_audience,json=resourceOwnerAudience" json:"resource_owner_audience,omitempty"`
}

func (m *RegisterResourceRequest) Reset()                    { *m = RegisterResourceRequest{} }
func (m *RegisterResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterResourceRequest) ProtoMessage()               {}
func (*RegisterResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *RegisterResourceRequest) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *RegisterResourceRequest) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *RegisterResourceRequest) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *RegisterResourceRequest) GetResourceOwnerServiceUrl() string {
	if m != nil {
		return m.ResourceOwnerServiceUrl
	}
	return ""
}

func (m *RegisterResourceRequest) GetRequiredResourceParams() []string {
	if m != nil {
		return m.RequiredResourceParams
	}
	return nil
}

func (m *RegisterResourceRequest) GetResourceOwnerAudience() string {
	if m != nil {
		return m.ResourceOwnerAudience
	}
	return ""
}

// RegisterResourceOwnerRequest is issued by a prospective ResourceOwner to tell IAM they intend to expose resources that IAM will control access to.
type RegisterResourceOwnerRequest struct {
	// owner is the definition of a resource owner
	Owner *ResourceOwner `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
}

func (m *RegisterResourceOwnerRequest) Reset()                    { *m = RegisterResourceOwnerRequest{} }
func (m *RegisterResourceOwnerRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterResourceOwnerRequest) ProtoMessage()               {}
func (*RegisterResourceOwnerRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *RegisterResourceOwnerRequest) GetOwner() *ResourceOwner {
	if m != nil {
		return m.Owner
	}
	return nil
}

// RegisterPolicyRequest registers a policy with a resource in IAM.
type RegisterPolicyRequest struct {
	Policy *Policy `protobuf:"bytes,1,opt,name=policy" json:"policy,omitempty"`
}

func (m *RegisterPolicyRequest) Reset()                    { *m = RegisterPolicyRequest{} }
func (m *RegisterPolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterPolicyRequest) ProtoMessage()               {}
func (*RegisterPolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *RegisterPolicyRequest) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

// SubjectResourceIntersectionClause is true if the set of values keyed by attribute_name on the resource has a non-empty
// intersection with the set of values keyed by resource_attribute_name (or optionally attribute_name if
// resource_attribute_name is not provided) on the subject. eg: with attribute_name = "account_group_id" then the subject
// MUST have an attribute named "account_group_id" that contains any individual value of the resource's
// "account_group_id" attribute for this clause to be considered TRUE.
type SubjectResourceIntersectionClause struct {
	AttributeName         string `protobuf:"bytes,1,opt,name=attribute_name,json=attributeName" json:"attribute_name,omitempty"`
	ResourceAttributeName string `protobuf:"bytes,2,opt,name=resource_attribute_name,json=resourceAttributeName" json:"resource_attribute_name,omitempty"`
}

func (m *SubjectResourceIntersectionClause) Reset()         { *m = SubjectResourceIntersectionClause{} }
func (m *SubjectResourceIntersectionClause) String() string { return proto.CompactTextString(m) }
func (*SubjectResourceIntersectionClause) ProtoMessage()    {}
func (*SubjectResourceIntersectionClause) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{4}
}

func (m *SubjectResourceIntersectionClause) GetAttributeName() string {
	if m != nil {
		return m.AttributeName
	}
	return ""
}

func (m *SubjectResourceIntersectionClause) GetResourceAttributeName() string {
	if m != nil {
		return m.ResourceAttributeName
	}
	return ""
}

// SubjectResourceSubsetClause is true if the set of values keyed by attribute_name on the resource is a subset of the set of values keyed by attribute_name on the subject.
type SubjectResourceSubsetClause struct {
	AttributeName string `protobuf:"bytes,1,opt,name=attribute_name,json=attributeName" json:"attribute_name,omitempty"`
}

func (m *SubjectResourceSubsetClause) Reset()                    { *m = SubjectResourceSubsetClause{} }
func (m *SubjectResourceSubsetClause) String() string            { return proto.CompactTextString(m) }
func (*SubjectResourceSubsetClause) ProtoMessage()               {}
func (*SubjectResourceSubsetClause) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *SubjectResourceSubsetClause) GetAttributeName() string {
	if m != nil {
		return m.AttributeName
	}
	return ""
}

// SubjectValueIntersectionClause describes how an attribute's value on the subject must contain the arbitrary value specified by attribute_value.
// eg: with attribute_name = "subject_type" and attribute_value = "partner", then the subject MUST have an attribute named
// "subject_type" that contains the value "partner". Note that this is different from SubjectResourceIntersectionClause because we don't
// care about this attributes presence on the resource or its value, it is purely for enforcing constraints on the subject itself.
type SubjectValueIntersectionClause struct {
	// Name of the attribute to compare against, use periods to denote inner struct attribute names
	AttributeName string `protobuf:"bytes,1,opt,name=attribute_name,json=attributeName" json:"attribute_name,omitempty"`
	// Deprecated: use structured_attribute_value instead
	AttributeValue string `protobuf:"bytes,2,opt,name=attribute_value,json=attributeValue" json:"attribute_value,omitempty"`
	// Attribute value to compare against, must be a non struct attribute
	StructuredAttributeValue *Attribute `protobuf:"bytes,3,opt,name=structured_attribute_value,json=structuredAttributeValue" json:"structured_attribute_value,omitempty"`
}

func (m *SubjectValueIntersectionClause) Reset()                    { *m = SubjectValueIntersectionClause{} }
func (m *SubjectValueIntersectionClause) String() string            { return proto.CompactTextString(m) }
func (*SubjectValueIntersectionClause) ProtoMessage()               {}
func (*SubjectValueIntersectionClause) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *SubjectValueIntersectionClause) GetAttributeName() string {
	if m != nil {
		return m.AttributeName
	}
	return ""
}

func (m *SubjectValueIntersectionClause) GetAttributeValue() string {
	if m != nil {
		return m.AttributeValue
	}
	return ""
}

func (m *SubjectValueIntersectionClause) GetStructuredAttributeValue() *Attribute {
	if m != nil {
		return m.StructuredAttributeValue
	}
	return nil
}

// SubjectMissingValueClause is true if the subject attribute keyed by attribute_name is either missing or has no values.
// eg: with attribute_name = "market_id", then a subject with "market_id" = [] is TRUE, a subject with "market_id" = ["something"] is FALSE,
// and if the subject simply doesn't have an attribute called "market_id" then this clause is TRUE
type SubjectMissingValueClause struct {
	AttributeName string `protobuf:"bytes,1,opt,name=attribute_name,json=attributeName" json:"attribute_name,omitempty"`
}

func (m *SubjectMissingValueClause) Reset()                    { *m = SubjectMissingValueClause{} }
func (m *SubjectMissingValueClause) String() string            { return proto.CompactTextString(m) }
func (*SubjectMissingValueClause) ProtoMessage()               {}
func (*SubjectMissingValueClause) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *SubjectMissingValueClause) GetAttributeName() string {
	if m != nil {
		return m.AttributeName
	}
	return ""
}

// SubjectResourceForClause will loop through a list of StructAttributes and return true if any or all match the PolicyNode defined.
// The Subject MUST have a ListAttribute that contains StructAttributes at the attribute_name key for this to be evaluated.
type SubjectResourceForClause struct {
	AttributeName string      `protobuf:"bytes,1,opt,name=attribute_name,json=attributeName" json:"attribute_name,omitempty"`
	Operator      ForOperator `protobuf:"varint,2,opt,name=operator,enum=iam.v1.ForOperator" json:"operator,omitempty"`
	Rules         *PolicyNode `protobuf:"bytes,3,opt,name=rules" json:"rules,omitempty"`
}

func (m *SubjectResourceForClause) Reset()                    { *m = SubjectResourceForClause{} }
func (m *SubjectResourceForClause) String() string            { return proto.CompactTextString(m) }
func (*SubjectResourceForClause) ProtoMessage()               {}
func (*SubjectResourceForClause) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *SubjectResourceForClause) GetAttributeName() string {
	if m != nil {
		return m.AttributeName
	}
	return ""
}

func (m *SubjectResourceForClause) GetOperator() ForOperator {
	if m != nil {
		return m.Operator
	}
	return ForOperator_ANY
}

func (m *SubjectResourceForClause) GetRules() *PolicyNode {
	if m != nil {
		return m.Rules
	}
	return nil
}

// Operator consists of a boolean conjunction and one to two children nodes.
// NOT is the only conjunction that supports a single child node, whereas AND and OR both require exactly two child nodes.
type Operator struct {
	Operator BooleanOperator `protobuf:"varint,1,opt,name=operator,enum=iam.v1.BooleanOperator" json:"operator,omitempty"`
	Children []*PolicyNode   `protobuf:"bytes,2,rep,name=children" json:"children,omitempty"`
}

func (m *Operator) Reset()                    { *m = Operator{} }
func (m *Operator) String() string            { return proto.CompactTextString(m) }
func (*Operator) ProtoMessage()               {}
func (*Operator) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *Operator) GetOperator() BooleanOperator {
	if m != nil {
		return m.Operator
	}
	return BooleanOperator_AND
}

func (m *Operator) GetChildren() []*PolicyNode {
	if m != nil {
		return m.Children
	}
	return nil
}

// A PolicyNode can either be a Boolean operator over one or more child PolicyNodes, or it can be an SubjectResourceIntersectionClause.
// A policy tree might look like this where C1, C2, C3 are SubjectResourceIntersectionClauses:
//          AND
//         /   \
//        C1   OR
//            /  \
//           C2  C3
// This means that the expression would be evaluated as C1 && (C2 || C3)
// Arbitrary nesting is valid.
type PolicyNode struct {
	// A policy node must either be a boolean conjunction of child clauses or an actual clause
	//
	// Types that are valid to be assigned to Value:
	//	*PolicyNode_SubjectResourceIntersection
	//	*PolicyNode_Operator
	//	*PolicyNode_SubjectValueIntersection
	//	*PolicyNode_SubjectMissingValue
	//	*PolicyNode_SubjectResourceSubset
	//	*PolicyNode_SubjectResourceFor
	Value isPolicyNode_Value `protobuf_oneof:"value"`
}

func (m *PolicyNode) Reset()                    { *m = PolicyNode{} }
func (m *PolicyNode) String() string            { return proto.CompactTextString(m) }
func (*PolicyNode) ProtoMessage()               {}
func (*PolicyNode) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

type isPolicyNode_Value interface {
	isPolicyNode_Value()
}

type PolicyNode_SubjectResourceIntersection struct {
	SubjectResourceIntersection *SubjectResourceIntersectionClause `protobuf:"bytes,1,opt,name=subject_resource_intersection,json=subjectResourceIntersection,oneof"`
}
type PolicyNode_Operator struct {
	Operator *Operator `protobuf:"bytes,2,opt,name=operator,oneof"`
}
type PolicyNode_SubjectValueIntersection struct {
	SubjectValueIntersection *SubjectValueIntersectionClause `protobuf:"bytes,3,opt,name=subject_value_intersection,json=subjectValueIntersection,oneof"`
}
type PolicyNode_SubjectMissingValue struct {
	SubjectMissingValue *SubjectMissingValueClause `protobuf:"bytes,4,opt,name=subject_missing_value,json=subjectMissingValue,oneof"`
}
type PolicyNode_SubjectResourceSubset struct {
	SubjectResourceSubset *SubjectResourceSubsetClause `protobuf:"bytes,5,opt,name=subject_resource_subset,json=subjectResourceSubset,oneof"`
}
type PolicyNode_SubjectResourceFor struct {
	SubjectResourceFor *SubjectResourceForClause `protobuf:"bytes,6,opt,name=subject_resource_for,json=subjectResourceFor,oneof"`
}

func (*PolicyNode_SubjectResourceIntersection) isPolicyNode_Value() {}
func (*PolicyNode_Operator) isPolicyNode_Value()                    {}
func (*PolicyNode_SubjectValueIntersection) isPolicyNode_Value()    {}
func (*PolicyNode_SubjectMissingValue) isPolicyNode_Value()         {}
func (*PolicyNode_SubjectResourceSubset) isPolicyNode_Value()       {}
func (*PolicyNode_SubjectResourceFor) isPolicyNode_Value()          {}

func (m *PolicyNode) GetValue() isPolicyNode_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PolicyNode) GetSubjectResourceIntersection() *SubjectResourceIntersectionClause {
	if x, ok := m.GetValue().(*PolicyNode_SubjectResourceIntersection); ok {
		return x.SubjectResourceIntersection
	}
	return nil
}

func (m *PolicyNode) GetOperator() *Operator {
	if x, ok := m.GetValue().(*PolicyNode_Operator); ok {
		return x.Operator
	}
	return nil
}

func (m *PolicyNode) GetSubjectValueIntersection() *SubjectValueIntersectionClause {
	if x, ok := m.GetValue().(*PolicyNode_SubjectValueIntersection); ok {
		return x.SubjectValueIntersection
	}
	return nil
}

func (m *PolicyNode) GetSubjectMissingValue() *SubjectMissingValueClause {
	if x, ok := m.GetValue().(*PolicyNode_SubjectMissingValue); ok {
		return x.SubjectMissingValue
	}
	return nil
}

func (m *PolicyNode) GetSubjectResourceSubset() *SubjectResourceSubsetClause {
	if x, ok := m.GetValue().(*PolicyNode_SubjectResourceSubset); ok {
		return x.SubjectResourceSubset
	}
	return nil
}

func (m *PolicyNode) GetSubjectResourceFor() *SubjectResourceForClause {
	if x, ok := m.GetValue().(*PolicyNode_SubjectResourceFor); ok {
		return x.SubjectResourceFor
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PolicyNode) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PolicyNode_OneofMarshaler, _PolicyNode_OneofUnmarshaler, _PolicyNode_OneofSizer, []interface{}{
		(*PolicyNode_SubjectResourceIntersection)(nil),
		(*PolicyNode_Operator)(nil),
		(*PolicyNode_SubjectValueIntersection)(nil),
		(*PolicyNode_SubjectMissingValue)(nil),
		(*PolicyNode_SubjectResourceSubset)(nil),
		(*PolicyNode_SubjectResourceFor)(nil),
	}
}

func _PolicyNode_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PolicyNode)
	// value
	switch x := m.Value.(type) {
	case *PolicyNode_SubjectResourceIntersection:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubjectResourceIntersection); err != nil {
			return err
		}
	case *PolicyNode_Operator:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Operator); err != nil {
			return err
		}
	case *PolicyNode_SubjectValueIntersection:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubjectValueIntersection); err != nil {
			return err
		}
	case *PolicyNode_SubjectMissingValue:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubjectMissingValue); err != nil {
			return err
		}
	case *PolicyNode_SubjectResourceSubset:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubjectResourceSubset); err != nil {
			return err
		}
	case *PolicyNode_SubjectResourceFor:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubjectResourceFor); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PolicyNode.Value has unexpected type %T", x)
	}
	return nil
}

func _PolicyNode_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PolicyNode)
	switch tag {
	case 1: // value.subject_resource_intersection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubjectResourceIntersectionClause)
		err := b.DecodeMessage(msg)
		m.Value = &PolicyNode_SubjectResourceIntersection{msg}
		return true, err
	case 2: // value.operator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Operator)
		err := b.DecodeMessage(msg)
		m.Value = &PolicyNode_Operator{msg}
		return true, err
	case 3: // value.subject_value_intersection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubjectValueIntersectionClause)
		err := b.DecodeMessage(msg)
		m.Value = &PolicyNode_SubjectValueIntersection{msg}
		return true, err
	case 4: // value.subject_missing_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubjectMissingValueClause)
		err := b.DecodeMessage(msg)
		m.Value = &PolicyNode_SubjectMissingValue{msg}
		return true, err
	case 5: // value.subject_resource_subset
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubjectResourceSubsetClause)
		err := b.DecodeMessage(msg)
		m.Value = &PolicyNode_SubjectResourceSubset{msg}
		return true, err
	case 6: // value.subject_resource_for
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubjectResourceForClause)
		err := b.DecodeMessage(msg)
		m.Value = &PolicyNode_SubjectResourceFor{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PolicyNode_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PolicyNode)
	// value
	switch x := m.Value.(type) {
	case *PolicyNode_SubjectResourceIntersection:
		s := proto.Size(x.SubjectResourceIntersection)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PolicyNode_Operator:
		s := proto.Size(x.Operator)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PolicyNode_SubjectValueIntersection:
		s := proto.Size(x.SubjectValueIntersection)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PolicyNode_SubjectMissingValue:
		s := proto.Size(x.SubjectMissingValue)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PolicyNode_SubjectResourceSubset:
		s := proto.Size(x.SubjectResourceSubset)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PolicyNode_SubjectResourceFor:
		s := proto.Size(x.SubjectResourceFor)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A policy is a binary boolean expression tree of attribute-based clauses that determines whether a subject is authorized to access a resource in a specific context.
type Policy struct {
	// app_id is a unique identifier for the ResourceOwner. It must be unique across all IAM resource owners. (eg "VBC")
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	// The unique identifier for the resource this policy will be applied to.
	ResourceId string `protobuf:"bytes,2,opt,name=resource_id,json=resourceId" json:"resource_id,omitempty"`
	// The identifier for this policy. This need only be unique within the scope of the resource.
	PolicyId string `protobuf:"bytes,3,opt,name=policy_id,json=policyId" json:"policy_id,omitempty"`
	// policy_name is the human readable name of the policy, often phrased as a question (eg: "Can user access account group?")
	PolicyName string `protobuf:"bytes,4,opt,name=policy_name,json=policyName" json:"policy_name,omitempty"`
	// Operations that a user may take on a resource.
	// In particular, these will be the operations that this policy is associated with, so if this policy is associated
	// with "read", and a user attempts to "read" this resource type, this policy would be evaluated.
	Operations []AccessScope `protobuf:"varint,5,rep,packed,name=operations,enum=iam.v1.AccessScope" json:"operations,omitempty"`
	// policy is the boolean expression tree of boolean operators and attribute-based clauses that expresses the method by which the policy is evaluated.
	Policy *PolicyNode `protobuf:"bytes,6,opt,name=policy" json:"policy,omitempty"`
}

func (m *Policy) Reset()                    { *m = Policy{} }
func (m *Policy) String() string            { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()               {}
func (*Policy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

func (m *Policy) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *Policy) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *Policy) GetPolicyId() string {
	if m != nil {
		return m.PolicyId
	}
	return ""
}

func (m *Policy) GetPolicyName() string {
	if m != nil {
		return m.PolicyName
	}
	return ""
}

func (m *Policy) GetOperations() []AccessScope {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *Policy) GetPolicy() *PolicyNode {
	if m != nil {
		return m.Policy
	}
	return nil
}

// ResourceIdentifier is a set of identifiers that a resource owner needs to identify a resource.
type ResourceIdentifier struct {
	// identifiers is a set of parameters that a resource owner needs to identify a resource.
	Identifiers map[string]*ValueList `protobuf:"bytes,1,rep,name=identifiers" json:"identifiers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ResourceIdentifier) Reset()                    { *m = ResourceIdentifier{} }
func (m *ResourceIdentifier) String() string            { return proto.CompactTextString(m) }
func (*ResourceIdentifier) ProtoMessage()               {}
func (*ResourceIdentifier) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *ResourceIdentifier) GetIdentifiers() map[string]*ValueList {
	if m != nil {
		return m.Identifiers
	}
	return nil
}

// AccessResourceRequest asks IAM whether a subject has access to a resource
type AccessResourceRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// Types that are valid to be assigned to SubjectIdentifier:
	//	*AccessResourceRequest_SubjectId
	//	*AccessResourceRequest_Email
	SubjectIdentifier isAccessResourceRequest_SubjectIdentifier `protobuf_oneof:"subject_identifier"`
	// Alternate way to retrieve the subject - by their IAM session ID
	Session string `protobuf:"bytes,8,opt,name=session" json:"session,omitempty"`
	// owner_id is the app_id of the ResourceOwner that owns the resource_id
	OwnerId string `protobuf:"bytes,4,opt,name=owner_id,json=ownerId" json:"owner_id,omitempty"`
	// resource_id is the resource type that the subject wants to access
	ResourceId string `protobuf:"bytes,5,opt,name=resource_id,json=resourceId" json:"resource_id,omitempty"`
	// deprecated: Use resource_entity_identifiers
	// resource_entity_identifier contains the information necessary to identify a specific resource of the type specified by resource_id
	ResourceEntityIdentifier map[string]*ValueList `protobuf:"bytes,6,rep,name=resource_entity_identifier,json=resourceEntityIdentifier" json:"resource_entity_identifier,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// access_scope represents the reasons that the user wants to access the resource.
	AccessScope []AccessScope `protobuf:"varint,7,rep,packed,name=access_scope,json=accessScope,enum=iam.v1.AccessScope" json:"access_scope,omitempty"`
	// resource_entity_identifiers contains the information necessary to identify a set of resources of the type specified by resource_id
	ResourceEntityIdentifiers []*ResourceIdentifier `protobuf:"bytes,9,rep,name=resource_entity_identifiers,json=resourceEntityIdentifiers" json:"resource_entity_identifiers,omitempty"`
	// resource_attributes contains the resource attributes to use during policy evaluation.
	// Only works for registered resources without a resource_owner_service_url specified.
	ResourceAttributes *StructAttribute `protobuf:"bytes,10,opt,name=resource_attributes,json=resourceAttributes" json:"resource_attributes,omitempty"`
}

func (m *AccessResourceRequest) Reset()                    { *m = AccessResourceRequest{} }
func (m *AccessResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*AccessResourceRequest) ProtoMessage()               {}
func (*AccessResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{13} }

type isAccessResourceRequest_SubjectIdentifier interface {
	isAccessResourceRequest_SubjectIdentifier()
}

type AccessResourceRequest_SubjectId struct {
	SubjectId string `protobuf:"bytes,2,opt,name=subject_id,json=subjectId,oneof"`
}
type AccessResourceRequest_Email struct {
	Email string `protobuf:"bytes,3,opt,name=email,oneof"`
}

func (*AccessResourceRequest_SubjectId) isAccessResourceRequest_SubjectIdentifier() {}
func (*AccessResourceRequest_Email) isAccessResourceRequest_SubjectIdentifier()     {}

func (m *AccessResourceRequest) GetSubjectIdentifier() isAccessResourceRequest_SubjectIdentifier {
	if m != nil {
		return m.SubjectIdentifier
	}
	return nil
}

func (m *AccessResourceRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *AccessResourceRequest) GetSubjectId() string {
	if x, ok := m.GetSubjectIdentifier().(*AccessResourceRequest_SubjectId); ok {
		return x.SubjectId
	}
	return ""
}

func (m *AccessResourceRequest) GetEmail() string {
	if x, ok := m.GetSubjectIdentifier().(*AccessResourceRequest_Email); ok {
		return x.Email
	}
	return ""
}

func (m *AccessResourceRequest) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *AccessResourceRequest) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *AccessResourceRequest) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *AccessResourceRequest) GetResourceEntityIdentifier() map[string]*ValueList {
	if m != nil {
		return m.ResourceEntityIdentifier
	}
	return nil
}

func (m *AccessResourceRequest) GetAccessScope() []AccessScope {
	if m != nil {
		return m.AccessScope
	}
	return nil
}

func (m *AccessResourceRequest) GetResourceEntityIdentifiers() []*ResourceIdentifier {
	if m != nil {
		return m.ResourceEntityIdentifiers
	}
	return nil
}

func (m *AccessResourceRequest) GetResourceAttributes() *StructAttribute {
	if m != nil {
		return m.ResourceAttributes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessResourceRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccessResourceRequest_OneofMarshaler, _AccessResourceRequest_OneofUnmarshaler, _AccessResourceRequest_OneofSizer, []interface{}{
		(*AccessResourceRequest_SubjectId)(nil),
		(*AccessResourceRequest_Email)(nil),
	}
}

func _AccessResourceRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessResourceRequest)
	// subject_identifier
	switch x := m.SubjectIdentifier.(type) {
	case *AccessResourceRequest_SubjectId:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.SubjectId)
	case *AccessResourceRequest_Email:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Email)
	case nil:
	default:
		return fmt.Errorf("AccessResourceRequest.SubjectIdentifier has unexpected type %T", x)
	}
	return nil
}

func _AccessResourceRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessResourceRequest)
	switch tag {
	case 2: // subject_identifier.subject_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SubjectIdentifier = &AccessResourceRequest_SubjectId{x}
		return true, err
	case 3: // subject_identifier.email
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SubjectIdentifier = &AccessResourceRequest_Email{x}
		return true, err
	default:
		return false, nil
	}
}

func _AccessResourceRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccessResourceRequest)
	// subject_identifier
	switch x := m.SubjectIdentifier.(type) {
	case *AccessResourceRequest_SubjectId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SubjectId)))
		n += len(x.SubjectId)
	case *AccessResourceRequest_Email:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Email)))
		n += len(x.Email)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ValueList is a holder for multiple string values in order to be compatible with map declarations
type ValueList struct {
	Values []string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *ValueList) Reset()                    { *m = ValueList{} }
func (m *ValueList) String() string            { return proto.CompactTextString(m) }
func (*ValueList) ProtoMessage()               {}
func (*ValueList) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{14} }

func (m *ValueList) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func init() {
	proto.RegisterType((*ResourceOwner)(nil), "iam.v1.ResourceOwner")
	proto.RegisterType((*RegisterResourceRequest)(nil), "iam.v1.RegisterResourceRequest")
	proto.RegisterType((*RegisterResourceOwnerRequest)(nil), "iam.v1.RegisterResourceOwnerRequest")
	proto.RegisterType((*RegisterPolicyRequest)(nil), "iam.v1.RegisterPolicyRequest")
	proto.RegisterType((*SubjectResourceIntersectionClause)(nil), "iam.v1.SubjectResourceIntersectionClause")
	proto.RegisterType((*SubjectResourceSubsetClause)(nil), "iam.v1.SubjectResourceSubsetClause")
	proto.RegisterType((*SubjectValueIntersectionClause)(nil), "iam.v1.SubjectValueIntersectionClause")
	proto.RegisterType((*SubjectMissingValueClause)(nil), "iam.v1.SubjectMissingValueClause")
	proto.RegisterType((*SubjectResourceForClause)(nil), "iam.v1.SubjectResourceForClause")
	proto.RegisterType((*Operator)(nil), "iam.v1.Operator")
	proto.RegisterType((*PolicyNode)(nil), "iam.v1.PolicyNode")
	proto.RegisterType((*Policy)(nil), "iam.v1.Policy")
	proto.RegisterType((*ResourceIdentifier)(nil), "iam.v1.ResourceIdentifier")
	proto.RegisterType((*AccessResourceRequest)(nil), "iam.v1.AccessResourceRequest")
	proto.RegisterType((*ValueList)(nil), "iam.v1.ValueList")
	proto.RegisterEnum("iam.v1.AccessScope", AccessScope_name, AccessScope_value)
	proto.RegisterEnum("iam.v1.ForOperator", ForOperator_name, ForOperator_value)
	proto.RegisterEnum("iam.v1.BooleanOperator", BooleanOperator_name, BooleanOperator_value)
}

func init() { proto.RegisterFile("iam/v1/resources.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 1147 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x57, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0x16, 0x25, 0xeb, 0xdf, 0x28, 0xb6, 0xf9, 0x5b, 0x47, 0x36, 0x2d, 0xff, 0x52, 0x3b, 0x34,
	0x9a, 0x3a, 0x36, 0x20, 0x23, 0x36, 0x10, 0x18, 0xcd, 0xa1, 0x90, 0x63, 0x05, 0x12, 0xea, 0xd8,
	0xe9, 0xca, 0x6d, 0xd0, 0x02, 0xad, 0x41, 0x53, 0xeb, 0x74, 0x5b, 0x89, 0x64, 0x76, 0x49, 0xb7,
	0x3e, 0xf4, 0xd2, 0xe7, 0xe8, 0xb1, 0xbd, 0xf5, 0xdc, 0x37, 0xe8, 0x73, 0xf4, 0x55, 0x0a, 0xee,
	0x1f, 0x92, 0xa2, 0xc2, 0x16, 0x6e, 0x6e, 0xe2, 0xce, 0xec, 0x37, 0x3b, 0xdf, 0x7c, 0xb3, 0xb3,
	0x82, 0x55, 0xea, 0x4c, 0xf7, 0x6f, 0x9e, 0xec, 0x33, 0xc2, 0xfd, 0x88, 0xb9, 0x84, 0x77, 0x03,
	0xe6, 0x87, 0x3e, 0xaa, 0x51, 0x67, 0xda, 0xbd, 0x79, 0xd2, 0x69, 0x2b, 0x3b, 0x8f, 0xae, 0xbe,
	0x23, 0x6e, 0xa8, 0xcc, 0x76, 0x0f, 0x16, 0xb1, 0xda, 0x71, 0xfe, 0x83, 0x47, 0x18, 0x6a, 0x43,
	0xcd, 0x09, 0x82, 0x4b, 0x3a, 0xb6, 0x8c, 0x2d, 0x63, 0xa7, 0x89, 0xab, 0x4e, 0x10, 0x0c, 0xc7,
	0x68, 0x1d, 0x1a, 0xf1, 0xb2, 0xe7, 0x4c, 0x89, 0x55, 0x16, 0x86, 0xba, 0x13, 0x04, 0x67, 0xce,
	0x94, 0xd8, 0xbf, 0x95, 0x61, 0x0d, 0x93, 0x37, 0x94, 0x87, 0x84, 0x69, 0x2c, 0x4c, 0xde, 0x46,
	0x84, 0x87, 0x45, 0x68, 0x9b, 0xd0, 0xd2, 0xe7, 0x8c, 0x6d, 0x12, 0x10, 0xf4, 0xd2, 0x70, 0x8c,
	0xb6, 0x61, 0x31, 0x71, 0x10, 0x31, 0x2b, 0xc2, 0xe5, 0x9e, 0x5e, 0x8c, 0x03, 0xa3, 0x67, 0xd0,
	0x49, 0x9c, 0xfc, 0xf8, 0xf0, 0x97, 0x9c, 0xb0, 0x1b, 0xea, 0x92, 0xcb, 0x88, 0x4d, 0xac, 0x05,
	0xb1, 0x63, 0x8d, 0x65, 0xb3, 0x1b, 0x49, 0xfb, 0xe7, 0x6c, 0x82, 0x8e, 0xc0, 0x62, 0xe4, 0x6d,
	0x44, 0x19, 0x19, 0x5f, 0x26, 0x28, 0x81, 0xc3, 0x9c, 0x29, 0xb7, 0xaa, 0x5b, 0x95, 0x9d, 0x26,
	0x5e, 0xd5, 0x76, 0x9d, 0xd4, 0x2b, 0x61, 0x45, 0x4f, 0x61, 0x2d, 0x17, 0xd6, 0x89, 0xc6, 0x94,
	0x78, 0x2e, 0xb1, 0x6a, 0x22, 0x66, 0x7b, 0x26, 0x66, 0x4f, 0x19, 0xed, 0x4f, 0xe1, 0xff, 0x79,
	0x9a, 0x84, 0x83, 0xe6, 0x6a, 0x0f, 0xaa, 0x02, 0x4e, 0x50, 0xd5, 0x3a, 0x68, 0x77, 0x65, 0xe5,
	0xba, 0xb3, 0xce, 0xd2, 0xc7, 0xfe, 0x04, 0xda, 0x1a, 0xec, 0x95, 0x3f, 0xa1, 0xee, 0xad, 0x46,
	0x79, 0x04, 0xb5, 0x40, 0x2c, 0x28, 0x98, 0x25, 0x0d, 0xa3, 0xdc, 0x94, 0xd5, 0xfe, 0xd9, 0x80,
	0x87, 0x23, 0xa9, 0x05, 0x1d, 0x60, 0xe8, 0x85, 0x84, 0x71, 0xe2, 0x86, 0xd4, 0xf7, 0x9e, 0x4f,
	0x9c, 0x88, 0x13, 0xf4, 0x21, 0x2c, 0x39, 0x61, 0xc8, 0xe8, 0x55, 0x14, 0xaa, 0x42, 0xc8, 0x3a,
	0x2e, 0x26, 0xab, 0xa2, 0x12, 0x59, 0x4a, 0x72, 0xfe, 0xe5, 0x59, 0x4a, 0x7a, 0xd9, 0x7d, 0xf6,
	0x09, 0x6c, 0xe4, 0xce, 0x30, 0x8a, 0xae, 0x38, 0x09, 0xef, 0x14, 0xdd, 0xfe, 0xd3, 0x80, 0x0f,
	0x14, 0xcc, 0x17, 0xce, 0x24, 0x7a, 0x8f, 0x3c, 0xf6, 0x60, 0x39, 0x75, 0xbb, 0x89, 0xb1, 0xe4,
	0xf9, 0x8f, 0xcb, 0x96, 0x81, 0x53, 0x04, 0x11, 0x05, 0x9d, 0x43, 0x87, 0x87, 0x2c, 0x72, 0xc3,
	0x28, 0xd6, 0x50, 0x7e, 0x5f, 0x45, 0xb0, 0xff, 0x3f, 0xcd, 0x7e, 0x92, 0x37, 0xb6, 0xd2, 0x4d,
	0xbd, 0x19, 0x40, 0xfb, 0x18, 0xd6, 0x55, 0x1a, 0x2f, 0x29, 0xe7, 0xd4, 0x7b, 0x23, 0x96, 0xef,
	0xc6, 0xc5, 0x2f, 0x06, 0x58, 0x39, 0x4a, 0x5f, 0xf8, 0xec, 0x6e, 0x2c, 0xec, 0x43, 0xc3, 0x0f,
	0x08, 0x73, 0x42, 0x9f, 0x89, 0xf4, 0x97, 0x0e, 0x56, 0x74, 0x1a, 0x2f, 0x7c, 0x76, 0xae, 0x4c,
	0x38, 0x71, 0x42, 0x3b, 0x50, 0x65, 0xd1, 0x84, 0x70, 0x95, 0x34, 0x9a, 0x95, 0xdc, 0x99, 0x3f,
	0x26, 0x58, 0x3a, 0xd8, 0x3e, 0x34, 0xf4, 0x7e, 0x74, 0x98, 0x09, 0x63, 0x88, 0x30, 0x6b, 0x7a,
	0xe3, 0xb1, 0xef, 0x4f, 0x88, 0xe3, 0xbd, 0x23, 0x54, 0x17, 0x1a, 0xee, 0xb7, 0x74, 0x32, 0x66,
	0xc4, 0xb3, 0xca, 0x5b, 0x95, 0x82, 0x68, 0x89, 0x8f, 0xfd, 0xfb, 0x02, 0x40, 0x6a, 0x40, 0x3e,
	0x3c, 0x50, 0x17, 0x60, 0xda, 0xf4, 0x34, 0x23, 0x17, 0xd5, 0x34, 0x8f, 0x35, 0xe6, 0xbf, 0x76,
	0xc8, 0xa0, 0x84, 0x37, 0x78, 0xb1, 0x53, 0x7c, 0xde, 0x19, 0x2e, 0x5b, 0x07, 0xa6, 0xc6, 0xd6,
	0xd9, 0x0d, 0x4a, 0x99, 0xfc, 0xae, 0xa1, 0xa3, 0x0f, 0x28, 0x74, 0x34, 0x7b, 0x3a, 0xc9, 0xef,
	0xa3, 0xdc, 0xe9, 0x0a, 0x44, 0x3f, 0x28, 0x61, 0x8b, 0x17, 0x78, 0xa0, 0xd7, 0xd0, 0xd6, 0x71,
	0xa6, 0x52, 0x6c, 0x4a, 0xb7, 0x0b, 0x22, 0xc4, 0xc3, 0x5c, 0x88, 0x79, 0x41, 0x0e, 0x4a, 0x78,
	0x85, 0xcf, 0x1b, 0xd1, 0xd7, 0xb0, 0x36, 0xc7, 0x30, 0x17, 0x4d, 0x6d, 0x55, 0x05, 0xf4, 0x76,
	0x01, 0xb7, 0xd9, 0xce, 0x1f, 0x94, 0x70, 0x9b, 0xbf, 0xcb, 0x8c, 0x2e, 0xe0, 0xfe, 0x1c, 0xfc,
	0xb5, 0xcf, 0xc4, 0xcd, 0xdb, 0x3a, 0xd8, 0x2a, 0xc0, 0x4e, 0x5a, 0x60, 0x50, 0xc2, 0x88, 0xcf,
	0xd9, 0x8e, 0xeb, 0x50, 0x15, 0xd9, 0xdb, 0x7f, 0x19, 0x50, 0x93, 0x72, 0xf9, 0xcf, 0xa3, 0x6b,
	0x03, 0x9a, 0xf2, 0x8a, 0x8d, 0xcd, 0x72, 0x6c, 0x35, 0xe4, 0x82, 0xdc, 0xad, 0x8c, 0xa2, 0xfd,
	0xe4, 0x8c, 0x02, 0xb9, 0x24, 0x7a, 0xef, 0x10, 0x40, 0x6a, 0x81, 0xfa, 0x9e, 0x1c, 0x44, 0x99,
	0xee, 0xeb, 0xb9, 0x2e, 0xe1, 0x7c, 0xe4, 0xfa, 0x01, 0xc1, 0x19, 0x37, 0xb4, 0x9b, 0xdc, 0xf9,
	0xb5, 0xc2, 0x06, 0xd4, 0xf7, 0xfe, 0x1f, 0x06, 0xa0, 0x44, 0xa9, 0x63, 0xe2, 0x85, 0xf4, 0x9a,
	0x12, 0x86, 0x5e, 0x42, 0x8b, 0x26, 0x5f, 0xdc, 0x32, 0x44, 0x6b, 0xed, 0xe5, 0x47, 0x50, 0xba,
	0xa1, 0x9b, 0xfe, 0xe4, 0x7d, 0x2f, 0x64, 0xb7, 0x38, 0xbb, 0xbf, 0xf3, 0x19, 0x98, 0x79, 0x07,
	0x64, 0x42, 0xe5, 0x7b, 0x72, 0xab, 0xd8, 0x8c, 0x7f, 0xa2, 0x8f, 0x14, 0xed, 0xaa, 0x33, 0x92,
	0xcb, 0x52, 0x28, 0xe9, 0x94, 0xf2, 0x10, 0x4b, 0xfb, 0xc7, 0xe5, 0x23, 0xc3, 0xfe, 0xb5, 0x0a,
	0x6d, 0x49, 0x40, 0xfe, 0x91, 0xf1, 0x18, 0xea, 0xae, 0xef, 0x85, 0xe4, 0xc7, 0x50, 0xb5, 0xef,
	0xb2, 0x06, 0x7a, 0x2e, 0x97, 0xb1, 0xb6, 0xa3, 0x4d, 0x00, 0x2d, 0x1f, 0x5d, 0xbc, 0x41, 0x09,
	0x37, 0xd5, 0xda, 0x70, 0x8c, 0x56, 0xa1, 0x4a, 0xa6, 0x0e, 0x9d, 0xc8, 0xca, 0x0d, 0x4a, 0x58,
	0x7e, 0x22, 0x0b, 0xea, 0x9c, 0x70, 0x1e, 0x37, 0x61, 0x43, 0x3e, 0x7f, 0xd4, 0x67, 0xfc, 0x32,
	0x92, 0xaf, 0x00, 0x3a, 0x56, 0xf5, 0xac, 0x8b, 0xef, 0x79, 0xad, 0x54, 0xe7, 0xb4, 0xf2, 0x53,
	0xe6, 0x05, 0x13, 0xb3, 0x15, 0xc6, 0xa2, 0xd1, 0xb4, 0x59, 0x35, 0x51, 0x84, 0x67, 0xb3, 0xd5,
	0xcf, 0x25, 0x9f, 0x94, 0xa6, 0x2f, 0xb6, 0xa7, 0xa4, 0x0b, 0xce, 0xc5, 0xdc, 0xb2, 0x58, 0x81,
	0x0b, 0x7a, 0x0a, 0xf7, 0x1c, 0x01, 0x7a, 0xc9, 0x63, 0x4d, 0x59, 0xf5, 0x62, 0xb9, 0xb5, 0x9c,
	0xf4, 0x03, 0x7d, 0x05, 0x1b, 0xc5, 0xc7, 0xe6, 0x56, 0x53, 0x9c, 0xbb, 0x53, 0x2c, 0x1e, 0xbc,
	0x5e, 0x74, 0x24, 0x8e, 0x06, 0xb0, 0x32, 0xff, 0x94, 0xe0, 0x16, 0x88, 0xc2, 0x26, 0x03, 0x62,
	0x24, 0x66, 0x68, 0x3a, 0x54, 0xd1, 0xdc, 0xfb, 0x82, 0x77, 0xbe, 0x81, 0x07, 0xff, 0x48, 0xce,
	0x7b, 0x0a, 0xf2, 0xf8, 0x3e, 0xa0, 0x54, 0x4b, 0x1a, 0xd9, 0xde, 0x86, 0x66, 0xe2, 0x8d, 0x56,
	0xa1, 0x26, 0xfc, 0x65, 0x43, 0x35, 0xb1, 0xfa, 0xda, 0x3d, 0x82, 0x56, 0x86, 0x5c, 0xd4, 0x80,
	0x05, 0xdc, 0xef, 0x9d, 0x98, 0x25, 0xd4, 0x84, 0xea, 0x6b, 0x3c, 0xbc, 0xe8, 0x9b, 0x06, 0x02,
	0xa8, 0x9d, 0xf4, 0x4f, 0xfb, 0x17, 0x7d, 0xb3, 0x1c, 0x3b, 0x9c, 0x0e, 0x47, 0x17, 0x66, 0x65,
	0x77, 0x13, 0x5a, 0x99, 0x19, 0x8c, 0xea, 0x50, 0xe9, 0x9d, 0x7d, 0x69, 0x96, 0xc4, 0x8f, 0xd3,
	0x53, 0xd3, 0xd8, 0xdd, 0x83, 0xe5, 0xdc, 0xf4, 0x94, 0x4e, 0x31, 0x7a, 0x0d, 0xca, 0xe7, 0xd8,
	0x34, 0xe2, 0x85, 0xb3, 0xf3, 0x0b, 0xb3, 0x7c, 0x55, 0x13, 0x7f, 0x02, 0x0e, 0xff, 0x0e, 0x00,
	0x00, 0xff, 0xff, 0xbe, 0xe5, 0x2b, 0x9e, 0x3d, 0x0c, 0x00, 0x00,
}
