// Code generated by protoc-gen-go. DO NOT EDIT.
// source: vetl/v1/api.proto

package vetl_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type CreateDataSourceRequest struct {
	// unique identifier for this data source
	SourceId string      `protobuf:"bytes,1,opt,name=source_id,json=sourceId" json:"source_id,omitempty"`
	Source   *DataSource `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
}

func (m *CreateDataSourceRequest) Reset()                    { *m = CreateDataSourceRequest{} }
func (m *CreateDataSourceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateDataSourceRequest) ProtoMessage()               {}
func (*CreateDataSourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *CreateDataSourceRequest) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *CreateDataSourceRequest) GetSource() *DataSource {
	if m != nil {
		return m.Source
	}
	return nil
}

type UpsertTransformRequest struct {
	// Whether or not this transform is visible to other services.
	Public bool `protobuf:"varint,1,opt,name=public" json:"public,omitempty"`
	// Identifier for this transform
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// The set of parent transform that this transform depends on.
	ParentIds []string `protobuf:"bytes,3,rep,name=parent_ids,json=parentIds" json:"parent_ids,omitempty"`
	// The definition of the transform
	Transform *Transform `protobuf:"bytes,4,opt,name=transform" json:"transform,omitempty"`
}

func (m *UpsertTransformRequest) Reset()                    { *m = UpsertTransformRequest{} }
func (m *UpsertTransformRequest) String() string            { return proto.CompactTextString(m) }
func (*UpsertTransformRequest) ProtoMessage()               {}
func (*UpsertTransformRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *UpsertTransformRequest) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

func (m *UpsertTransformRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpsertTransformRequest) GetParentIds() []string {
	if m != nil {
		return m.ParentIds
	}
	return nil
}

func (m *UpsertTransformRequest) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

type CreateSubscriptionRequest struct {
	// Identifier for this subscription
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Identifier of the transform to subscribe to
	ParentId string    `protobuf:"bytes,2,opt,name=parent_id,json=parentId" json:"parent_id,omitempty"`
	Sink     *DataSink `protobuf:"bytes,3,opt,name=sink" json:"sink,omitempty"`
}

func (m *CreateSubscriptionRequest) Reset()                    { *m = CreateSubscriptionRequest{} }
func (m *CreateSubscriptionRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateSubscriptionRequest) ProtoMessage()               {}
func (*CreateSubscriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *CreateSubscriptionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateSubscriptionRequest) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *CreateSubscriptionRequest) GetSink() *DataSink {
	if m != nil {
		return m.Sink
	}
	return nil
}

type BackfillSubscriptionRequest struct {
	// Identifier of the subscription to backfill
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *BackfillSubscriptionRequest) Reset()                    { *m = BackfillSubscriptionRequest{} }
func (m *BackfillSubscriptionRequest) String() string            { return proto.CompactTextString(m) }
func (*BackfillSubscriptionRequest) ProtoMessage()               {}
func (*BackfillSubscriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *BackfillSubscriptionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterType((*CreateDataSourceRequest)(nil), "vetl.v1.CreateDataSourceRequest")
	proto.RegisterType((*UpsertTransformRequest)(nil), "vetl.v1.UpsertTransformRequest")
	proto.RegisterType((*CreateSubscriptionRequest)(nil), "vetl.v1.CreateSubscriptionRequest")
	proto.RegisterType((*BackfillSubscriptionRequest)(nil), "vetl.v1.BackfillSubscriptionRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VETL service

type VETLClient interface {
	// Create a data source
	CreateDataSource(ctx context.Context, in *CreateDataSourceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Insert or Update a transform
	UpsertTransform(ctx context.Context, in *UpsertTransformRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Create a subscription to a transform's output
	CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Backfill a subscription with all data from all its sources.
	// This should be triggered manually and used to migrate/transform historical data.
	BackfillSubscription(ctx context.Context, in *BackfillSubscriptionRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type vETLClient struct {
	cc *grpc.ClientConn
}

func NewVETLClient(cc *grpc.ClientConn) VETLClient {
	return &vETLClient{cc}
}

func (c *vETLClient) CreateDataSource(ctx context.Context, in *CreateDataSourceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/vetl.v1.VETL/CreateDataSource", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vETLClient) UpsertTransform(ctx context.Context, in *UpsertTransformRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/vetl.v1.VETL/UpsertTransform", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vETLClient) CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/vetl.v1.VETL/CreateSubscription", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vETLClient) BackfillSubscription(ctx context.Context, in *BackfillSubscriptionRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/vetl.v1.VETL/BackfillSubscription", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VETL service

type VETLServer interface {
	// Create a data source
	CreateDataSource(context.Context, *CreateDataSourceRequest) (*google_protobuf.Empty, error)
	// Insert or Update a transform
	UpsertTransform(context.Context, *UpsertTransformRequest) (*google_protobuf.Empty, error)
	// Create a subscription to a transform's output
	CreateSubscription(context.Context, *CreateSubscriptionRequest) (*google_protobuf.Empty, error)
	// Backfill a subscription with all data from all its sources.
	// This should be triggered manually and used to migrate/transform historical data.
	BackfillSubscription(context.Context, *BackfillSubscriptionRequest) (*google_protobuf.Empty, error)
}

func RegisterVETLServer(s *grpc.Server, srv VETLServer) {
	s.RegisterService(&_VETL_serviceDesc, srv)
}

func _VETL_CreateDataSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDataSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VETLServer).CreateDataSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vetl.v1.VETL/CreateDataSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VETLServer).CreateDataSource(ctx, req.(*CreateDataSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VETL_UpsertTransform_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertTransformRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VETLServer).UpsertTransform(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vetl.v1.VETL/UpsertTransform",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VETLServer).UpsertTransform(ctx, req.(*UpsertTransformRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VETL_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VETLServer).CreateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vetl.v1.VETL/CreateSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VETLServer).CreateSubscription(ctx, req.(*CreateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VETL_BackfillSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackfillSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VETLServer).BackfillSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vetl.v1.VETL/BackfillSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VETLServer).BackfillSubscription(ctx, req.(*BackfillSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VETL_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vetl.v1.VETL",
	HandlerType: (*VETLServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDataSource",
			Handler:    _VETL_CreateDataSource_Handler,
		},
		{
			MethodName: "UpsertTransform",
			Handler:    _VETL_UpsertTransform_Handler,
		},
		{
			MethodName: "CreateSubscription",
			Handler:    _VETL_CreateSubscription_Handler,
		},
		{
			MethodName: "BackfillSubscription",
			Handler:    _VETL_BackfillSubscription_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vetl/v1/api.proto",
}

func init() { proto.RegisterFile("vetl/v1/api.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 397 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x92, 0xdb, 0xce, 0xd2, 0x40,
	0x14, 0x85, 0x6d, 0x21, 0x48, 0xb7, 0x89, 0xca, 0x96, 0x40, 0xa5, 0x31, 0x36, 0x8d, 0x26, 0x24,
	0xc6, 0x56, 0xf0, 0x0d, 0x54, 0x2e, 0x48, 0x88, 0x17, 0x05, 0xb9, 0x25, 0x3d, 0x0c, 0x64, 0x42,
	0xe9, 0xd4, 0xe9, 0x94, 0xc4, 0xc7, 0xf0, 0xcd, 0x7c, 0x24, 0xc3, 0x4c, 0x3b, 0x28, 0x3f, 0x90,
	0xff, 0x0e, 0xd6, 0xec, 0xae, 0x6f, 0xed, 0x03, 0xf4, 0x8e, 0x44, 0x64, 0xc1, 0x71, 0x12, 0x44,
	0x05, 0xf5, 0x0b, 0xce, 0x04, 0xc3, 0xa7, 0x27, 0xc9, 0x3f, 0x4e, 0x46, 0xce, 0x8e, 0xb1, 0x5d,
	0x46, 0x02, 0x29, 0xc7, 0xd5, 0x36, 0x20, 0x87, 0x42, 0xfc, 0x52, 0x55, 0xa3, 0x7e, 0xf3, 0x61,
	0xc9, 0x2a, 0x9e, 0x90, 0x5a, 0x45, 0xad, 0xd2, 0x7c, 0x5f, 0x6b, 0xc3, 0x46, 0x13, 0x3c, 0xca,
	0xcb, 0x2d, 0xe3, 0x07, 0xf5, 0xe0, 0x25, 0x30, 0xfc, 0xca, 0x49, 0x24, 0xc8, 0xb7, 0x48, 0x44,
	0x4b, 0x69, 0x13, 0x92, 0x9f, 0x15, 0x29, 0x05, 0x3a, 0x60, 0x29, 0xdf, 0x0d, 0x4d, 0x6d, 0xc3,
	0x35, 0xc6, 0x56, 0xd8, 0x55, 0xc2, 0x3c, 0xc5, 0x0f, 0xd0, 0x51, 0xbf, 0x6d, 0xd3, 0x35, 0xc6,
	0xcf, 0xa6, 0xaf, 0xfc, 0x3a, 0xb1, 0xff, 0x8f, 0x51, 0x5d, 0xe2, 0xfd, 0x36, 0x60, 0xf0, 0xa3,
	0x28, 0x09, 0x17, 0xab, 0x06, 0xdf, 0x40, 0x06, 0xd0, 0x29, 0xaa, 0x38, 0xa3, 0x89, 0x24, 0x74,
	0xc3, 0xfa, 0x1f, 0x3e, 0x07, 0x93, 0xa6, 0xd2, 0xdb, 0x0a, 0x4d, 0x9a, 0xe2, 0x1b, 0x80, 0x22,
	0xe2, 0x24, 0x17, 0x1b, 0x9a, 0x96, 0x76, 0xcb, 0x6d, 0x8d, 0xad, 0xd0, 0x52, 0xca, 0x3c, 0x2d,
	0xf1, 0x13, 0x58, 0xba, 0x33, 0xbb, 0x2d, 0x13, 0xa1, 0x4e, 0x74, 0x86, 0x9e, 0x8b, 0x3c, 0x06,
	0xaf, 0x55, 0xe3, 0xcb, 0x2a, 0x2e, 0x13, 0x4e, 0x0b, 0x41, 0x59, 0xde, 0xa4, 0x52, 0x74, 0x43,
	0xd3, 0x1d, 0xb0, 0x34, 0xbd, 0x0e, 0xd5, 0x6d, 0xe0, 0xf8, 0x1e, 0xda, 0xa7, 0x49, 0xdb, 0x2d,
	0x89, 0xed, 0xfd, 0x3f, 0x08, 0x9a, 0xef, 0x43, 0xf9, 0xec, 0x7d, 0x04, 0xe7, 0x4b, 0x94, 0xec,
	0xb7, 0x34, 0xcb, 0x1e, 0x81, 0x9c, 0xfe, 0x31, 0xa1, 0xbd, 0x9e, 0xad, 0x16, 0xf8, 0x1d, 0x5e,
	0x5e, 0x6e, 0x08, 0x5d, 0x0d, 0xb9, 0xb1, 0xbc, 0xd1, 0xc0, 0x57, 0x87, 0xe3, 0x37, 0x87, 0xe3,
	0xcf, 0x4e, 0x87, 0xe3, 0x3d, 0xc1, 0x05, 0xbc, 0xb8, 0xd8, 0x05, 0xbe, 0xd5, 0x76, 0xd7, 0xb7,
	0x74, 0xc7, 0x2d, 0x04, 0x7c, 0x38, 0x46, 0xf4, 0x2e, 0xf2, 0x5d, 0x69, 0xf8, 0x8e, 0xe7, 0x1a,
	0xfa, 0xd7, 0x26, 0x85, 0xef, 0xb4, 0xeb, 0x9d, 0x41, 0xde, 0xf6, 0x8d, 0x3b, 0x52, 0xf9, 0xfc,
	0x37, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x86, 0x5b, 0xe1, 0x70, 0x03, 0x00, 0x00,
}
