// Code generated by protoc-gen-go. DO NOT EDIT.
// source: vetl/v1/source.proto

package vetl_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Describes the schema associated with a particular source and how it is provided to vETL
type DataSource struct {
	// The Provider contains all the metadata necessary for vETL to read data from a particular source
	//
	// Types that are valid to be assigned to Provider:
	//	*DataSource_Vstore
	//	*DataSource_Datastore
	Provider isDataSource_Provider `protobuf_oneof:"provider"`
	// Defines how the data is structured.
	Schema *Schema `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
}

func (m *DataSource) Reset()                    { *m = DataSource{} }
func (m *DataSource) String() string            { return proto.CompactTextString(m) }
func (*DataSource) ProtoMessage()               {}
func (*DataSource) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type isDataSource_Provider interface {
	isDataSource_Provider()
}

type DataSource_Vstore struct {
	Vstore *VStoreSource `protobuf:"bytes,1,opt,name=vstore,oneof"`
}
type DataSource_Datastore struct {
	Datastore *DatastoreSource `protobuf:"bytes,3,opt,name=datastore,oneof"`
}

func (*DataSource_Vstore) isDataSource_Provider()    {}
func (*DataSource_Datastore) isDataSource_Provider() {}

func (m *DataSource) GetProvider() isDataSource_Provider {
	if m != nil {
		return m.Provider
	}
	return nil
}

func (m *DataSource) GetVstore() *VStoreSource {
	if x, ok := m.GetProvider().(*DataSource_Vstore); ok {
		return x.Vstore
	}
	return nil
}

func (m *DataSource) GetDatastore() *DatastoreSource {
	if x, ok := m.GetProvider().(*DataSource_Datastore); ok {
		return x.Datastore
	}
	return nil
}

func (m *DataSource) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DataSource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DataSource_OneofMarshaler, _DataSource_OneofUnmarshaler, _DataSource_OneofSizer, []interface{}{
		(*DataSource_Vstore)(nil),
		(*DataSource_Datastore)(nil),
	}
}

func _DataSource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DataSource)
	// provider
	switch x := m.Provider.(type) {
	case *DataSource_Vstore:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vstore); err != nil {
			return err
		}
	case *DataSource_Datastore:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Datastore); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DataSource.Provider has unexpected type %T", x)
	}
	return nil
}

func _DataSource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DataSource)
	switch tag {
	case 1: // provider.vstore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VStoreSource)
		err := b.DecodeMessage(msg)
		m.Provider = &DataSource_Vstore{msg}
		return true, err
	case 3: // provider.datastore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DatastoreSource)
		err := b.DecodeMessage(msg)
		m.Provider = &DataSource_Datastore{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DataSource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DataSource)
	// provider
	switch x := m.Provider.(type) {
	case *DataSource_Vstore:
		s := proto.Size(x.Vstore)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataSource_Datastore:
		s := proto.Size(x.Datastore)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VStoreSource contains the necessary information for vETL to be able to read data from a particular VStore table
type VStoreSource struct {
	Namespace  string   `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	Kind       string   `protobuf:"bytes,2,opt,name=kind" json:"kind,omitempty"`
	PrimaryKey []string `protobuf:"bytes,3,rep,name=primary_key,json=primaryKey" json:"primary_key,omitempty"`
	// The index id of a pubsub secondary index that is suitable for vETL to read from in order to transform new data
	PubsubIndexId string `protobuf:"bytes,4,opt,name=pubsub_index_id,json=pubsubIndexId" json:"pubsub_index_id,omitempty"`
}

func (m *VStoreSource) Reset()                    { *m = VStoreSource{} }
func (m *VStoreSource) String() string            { return proto.CompactTextString(m) }
func (*VStoreSource) ProtoMessage()               {}
func (*VStoreSource) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *VStoreSource) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *VStoreSource) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *VStoreSource) GetPrimaryKey() []string {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

func (m *VStoreSource) GetPubsubIndexId() string {
	if m != nil {
		return m.PubsubIndexId
	}
	return ""
}

// DatastoreSource contains the necessary information for vETL to be able to read data from a particular Cloud Datastore table
// This source is throttled and will not provide updates in true realtime.
// Instead, updates are processed in bucketed windows, to rectify race conditions with creating/deleting in quick succession.
type DatastoreSource struct {
	Namespace *DatastoreSource_Namespace `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	// the name of the table
	Kind string `protobuf:"bytes,2,opt,name=kind" json:"kind,omitempty"`
	// the topic name of the pubsub intake that will notify vETL of changes to entities
	IntakePubsubTopic string `protobuf:"bytes,3,opt,name=intake_pubsub_topic,json=intakePubsubTopic" json:"intake_pubsub_topic,omitempty"`
	// the project id of the cloud datastore instance and intake_pubsub_topic
	ProjectId string `protobuf:"bytes,4,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
}

func (m *DatastoreSource) Reset()                    { *m = DatastoreSource{} }
func (m *DatastoreSource) String() string            { return proto.CompactTextString(m) }
func (*DatastoreSource) ProtoMessage()               {}
func (*DatastoreSource) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *DatastoreSource) GetNamespace() *DatastoreSource_Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *DatastoreSource) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *DatastoreSource) GetIntakePubsubTopic() string {
	if m != nil {
		return m.IntakePubsubTopic
	}
	return ""
}

func (m *DatastoreSource) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

type DatastoreSource_Namespace struct {
	// identifies the datastore namespace that the table lives under. Empty value here means the top level (empty) namespace.
	Namespace string `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	// if true, the model is contained in many namespaces, potentially all namespaces.
	All bool `protobuf:"varint,2,opt,name=all" json:"all,omitempty"`
}

func (m *DatastoreSource_Namespace) Reset()                    { *m = DatastoreSource_Namespace{} }
func (m *DatastoreSource_Namespace) String() string            { return proto.CompactTextString(m) }
func (*DatastoreSource_Namespace) ProtoMessage()               {}
func (*DatastoreSource_Namespace) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2, 0} }

func (m *DatastoreSource_Namespace) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DatastoreSource_Namespace) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func init() {
	proto.RegisterType((*DataSource)(nil), "vetl.v1.DataSource")
	proto.RegisterType((*VStoreSource)(nil), "vetl.v1.VStoreSource")
	proto.RegisterType((*DatastoreSource)(nil), "vetl.v1.DatastoreSource")
	proto.RegisterType((*DatastoreSource_Namespace)(nil), "vetl.v1.DatastoreSource.Namespace")
}

func init() { proto.RegisterFile("vetl/v1/source.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 346 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x92, 0xd1, 0x4a, 0xf3, 0x30,
	0x14, 0xc7, 0xbf, 0x7e, 0x1d, 0x73, 0x39, 0x53, 0xa6, 0x51, 0xa1, 0x0c, 0xc5, 0xd1, 0x0b, 0xdd,
	0x55, 0xc7, 0xe6, 0x8d, 0xe0, 0x8d, 0xc8, 0x2e, 0x1c, 0x82, 0x48, 0x26, 0xde, 0x96, 0xac, 0x09,
	0x18, 0xb7, 0x35, 0x21, 0xcd, 0x8a, 0x7d, 0x04, 0xdf, 0xc5, 0xb7, 0xf3, 0x05, 0xa4, 0x69, 0xd6,
	0xc9, 0x40, 0x76, 0x17, 0x7e, 0xff, 0xf3, 0xe3, 0xfc, 0x7b, 0x28, 0x9c, 0xe4, 0xdc, 0x2c, 0x06,
	0xf9, 0x70, 0x90, 0xc9, 0x95, 0x4e, 0x78, 0xa4, 0xb4, 0x34, 0x12, 0xef, 0x95, 0x34, 0xca, 0x87,
	0xdd, 0x3a, 0xe6, 0xa9, 0x11, 0xa6, 0xa8, 0xe2, 0xf0, 0xcb, 0x03, 0x18, 0x53, 0x43, 0xa7, 0xd6,
	0xc1, 0x03, 0x68, 0xe6, 0x99, 0x91, 0x9a, 0x07, 0x5e, 0xcf, 0xeb, 0xb7, 0x47, 0xa7, 0x91, 0xd3,
	0xa3, 0xd7, 0x69, 0x89, 0xab, 0xb1, 0x87, 0x7f, 0xc4, 0x8d, 0xe1, 0x1b, 0x40, 0x8c, 0x1a, 0x5a,
	0x39, 0xbe, 0x75, 0x82, 0xda, 0x19, 0xaf, 0x93, 0x5a, 0xdb, 0x0c, 0xe3, 0x2b, 0x68, 0x66, 0xc9,
	0x1b, 0x5f, 0xd2, 0xe0, 0xbf, 0xd5, 0x3a, 0xb5, 0x36, 0xb5, 0x98, 0xb8, 0xf8, 0x1e, 0xa0, 0xa5,
	0xb4, 0xcc, 0x05, 0xe3, 0x3a, 0xfc, 0xf4, 0x60, 0xff, 0x77, 0x13, 0x7c, 0x06, 0x28, 0xa5, 0x4b,
	0x9e, 0x29, 0x9a, 0x54, 0x9d, 0x11, 0xd9, 0x00, 0x8c, 0xa1, 0x31, 0x17, 0x29, 0xb3, 0x1b, 0x10,
	0xb1, 0x6f, 0x7c, 0x01, 0x6d, 0xa5, 0xc5, 0x92, 0xea, 0x22, 0x9e, 0xf3, 0x22, 0xf0, 0x7b, 0x7e,
	0x1f, 0x11, 0x70, 0xe8, 0x91, 0x17, 0xf8, 0x12, 0x3a, 0x6a, 0x35, 0xcb, 0x56, 0xb3, 0x58, 0xa4,
	0x8c, 0x7f, 0xc4, 0x82, 0x05, 0x0d, 0xeb, 0x1f, 0x54, 0x78, 0x52, 0xd2, 0x09, 0x0b, 0xbf, 0x3d,
	0xe8, 0x6c, 0x7d, 0x21, 0xbe, 0xdb, 0xae, 0xd3, 0x1e, 0x85, 0x7f, 0x9d, 0x23, 0x7a, 0x5a, 0x4f,
	0xee, 0xaa, 0x1c, 0xc1, 0xb1, 0x48, 0x0d, 0x9d, 0xf3, 0xd8, 0x15, 0x33, 0x52, 0x89, 0xc4, 0x9e,
	0x1b, 0x91, 0xa3, 0x2a, 0x7a, 0xb6, 0xc9, 0x4b, 0x19, 0xe0, 0x73, 0x00, 0xa5, 0xe5, 0x3b, 0x4f,
	0xcc, 0xa6, 0x3c, 0x72, 0x64, 0xc2, 0xba, 0xb7, 0x80, 0xea, 0xd5, 0x3b, 0x0e, 0x78, 0x08, 0x3e,
	0x5d, 0x2c, 0x6c, 0x99, 0x16, 0x29, 0x9f, 0xb3, 0xa6, 0xfd, 0x6f, 0xae, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0xbf, 0xd2, 0x8a, 0x09, 0x6e, 0x02, 0x00, 0x00,
}
