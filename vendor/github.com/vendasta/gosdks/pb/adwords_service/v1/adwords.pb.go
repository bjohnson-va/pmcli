// Code generated by protoc-gen-go. DO NOT EDIT.
// source: adwords_service/v1/adwords.proto

/*
Package adwords_v1 is a generated protocol buffer package.

It is generated from these files:
	adwords_service/v1/adwords.proto
	adwords_service/v1/api.proto

It has these top-level messages:
	GetKeywordSuggestionsRequest
	GetKeywordSuggestionsResponse
	Keyword
	KeywordEstimationRequest
	GetCampaignPerformanceEstimationRequest
	KeywordEstimation
	PerformanceEstimateRange
	PerformanceEstimation
	GetCampaignPerformanceEstimationResponse
	GetAccountPerformanceRequest
	GetAccountPerformanceResponse
	Account
	ListAllAccountsRequest
	ListAllAccountsResponse
*/
package adwords_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Represents different matching strategies for keywords
type Keyword_MatchType int32

const (
	Keyword_EXACT  Keyword_MatchType = 0
	Keyword_BROAD  Keyword_MatchType = 1
	Keyword_PHRASE Keyword_MatchType = 2
)

var Keyword_MatchType_name = map[int32]string{
	0: "EXACT",
	1: "BROAD",
	2: "PHRASE",
}
var Keyword_MatchType_value = map[string]int32{
	"EXACT":  0,
	"BROAD":  1,
	"PHRASE": 2,
}

func (x Keyword_MatchType) String() string {
	return proto.EnumName(Keyword_MatchType_name, int32(x))
}
func (Keyword_MatchType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

// A request for keyword suggestions based on provided data.
type GetKeywordSuggestionsRequest struct {
	// A google search term from which to generate keywords
	SearchTerm []string `protobuf:"bytes,1,rep,name=search_term,json=searchTerm" json:"search_term,omitempty"`
	// Possible queries must include the following strings
	Including []string `protobuf:"bytes,2,rep,name=including" json:"including,omitempty"`
	// Possible queries must not include the following strings
	Excluding []string `protobuf:"bytes,3,rep,name=excluding" json:"excluding,omitempty"`
	// List of preferred languages
	Language []int64 `protobuf:"varint,4,rep,packed,name=language" json:"language,omitempty"`
	// Category ID according to Google's list: https://support.google.com/merchants/answer/6324436?hl=en
	CategoryId []int32 `protobuf:"varint,5,rep,packed,name=category_id,json=categoryId" json:"category_id,omitempty"`
	// Include adult content in the results
	IncludeNsfw bool `protobuf:"varint,6,opt,name=include_nsfw,json=includeNsfw" json:"include_nsfw,omitempty"`
	// Restrict level of competition on suggestions,
	// 0 is off, 1 = low, 2 = med, 3 = high
	CompetitionLevel int32 `protobuf:"varint,7,opt,name=competition_level,json=competitionLevel" json:"competition_level,omitempty"`
	// 0 or 1 URL strings to which search results should be related
	RelatedUrl []string `protobuf:"bytes,8,rep,name=related_url,json=relatedUrl" json:"related_url,omitempty"`
	// unique location id representing city/zip/state/etc
	// https://fusiontables.google.com/DataSource?docid=1GF8rHWjkeLDLDt1WpqujyCelrgd0hq4bGYobmXAn
	LocationId int64 `protobuf:"varint,9,opt,name=location_id,json=locationId" json:"location_id,omitempty"`
}

func (m *GetKeywordSuggestionsRequest) Reset()                    { *m = GetKeywordSuggestionsRequest{} }
func (m *GetKeywordSuggestionsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetKeywordSuggestionsRequest) ProtoMessage()               {}
func (*GetKeywordSuggestionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GetKeywordSuggestionsRequest) GetSearchTerm() []string {
	if m != nil {
		return m.SearchTerm
	}
	return nil
}

func (m *GetKeywordSuggestionsRequest) GetIncluding() []string {
	if m != nil {
		return m.Including
	}
	return nil
}

func (m *GetKeywordSuggestionsRequest) GetExcluding() []string {
	if m != nil {
		return m.Excluding
	}
	return nil
}

func (m *GetKeywordSuggestionsRequest) GetLanguage() []int64 {
	if m != nil {
		return m.Language
	}
	return nil
}

func (m *GetKeywordSuggestionsRequest) GetCategoryId() []int32 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *GetKeywordSuggestionsRequest) GetIncludeNsfw() bool {
	if m != nil {
		return m.IncludeNsfw
	}
	return false
}

func (m *GetKeywordSuggestionsRequest) GetCompetitionLevel() int32 {
	if m != nil {
		return m.CompetitionLevel
	}
	return 0
}

func (m *GetKeywordSuggestionsRequest) GetRelatedUrl() []string {
	if m != nil {
		return m.RelatedUrl
	}
	return nil
}

func (m *GetKeywordSuggestionsRequest) GetLocationId() int64 {
	if m != nil {
		return m.LocationId
	}
	return 0
}

// The response message containing a keyword suggestion
type GetKeywordSuggestionsResponse struct {
	// A list of suggestions for advertising keywords
	Keywords []string `protobuf:"bytes,1,rep,name=keywords" json:"keywords,omitempty"`
}

func (m *GetKeywordSuggestionsResponse) Reset()                    { *m = GetKeywordSuggestionsResponse{} }
func (m *GetKeywordSuggestionsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetKeywordSuggestionsResponse) ProtoMessage()               {}
func (*GetKeywordSuggestionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetKeywordSuggestionsResponse) GetKeywords() []string {
	if m != nil {
		return m.Keywords
	}
	return nil
}

// Represents an adwords keyword
type Keyword struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	// The type of match to perform
	MatchType Keyword_MatchType `protobuf:"varint,2,opt,name=match_type,json=matchType,enum=adwords.v1.Keyword_MatchType" json:"match_type,omitempty"`
}

func (m *Keyword) Reset()                    { *m = Keyword{} }
func (m *Keyword) String() string            { return proto.CompactTextString(m) }
func (*Keyword) ProtoMessage()               {}
func (*Keyword) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Keyword) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Keyword) GetMatchType() Keyword_MatchType {
	if m != nil {
		return m.MatchType
	}
	return Keyword_EXACT
}

// A request for a performance estimation of a keyword
type KeywordEstimationRequest struct {
	// The keyword or phrase to estimate for
	Keyword *Keyword `protobuf:"bytes,1,opt,name=keyword" json:"keyword,omitempty"`
	// If 'negative' then searches containing this keyword will be excluded
	IsNegative bool `protobuf:"varint,2,opt,name=is_negative,json=isNegative" json:"is_negative,omitempty"`
	// Bound the estimates by a maximum cost per click (in Micros)
	MaxCpc int64 `protobuf:"varint,3,opt,name=max_cpc,json=maxCpc" json:"max_cpc,omitempty"`
}

func (m *KeywordEstimationRequest) Reset()                    { *m = KeywordEstimationRequest{} }
func (m *KeywordEstimationRequest) String() string            { return proto.CompactTextString(m) }
func (*KeywordEstimationRequest) ProtoMessage()               {}
func (*KeywordEstimationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *KeywordEstimationRequest) GetKeyword() *Keyword {
	if m != nil {
		return m.Keyword
	}
	return nil
}

func (m *KeywordEstimationRequest) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

func (m *KeywordEstimationRequest) GetMaxCpc() int64 {
	if m != nil {
		return m.MaxCpc
	}
	return 0
}

// A request for a performance estimation of a group of keywords
type GetCampaignPerformanceEstimationRequest struct {
	// A List of keywords to estimate on
	KeywordRequests []*KeywordEstimationRequest `protobuf:"bytes,1,rep,name=keyword_requests,json=keywordRequests" json:"keyword_requests,omitempty"`
	// Maximum daily budget (in Micros)
	DailyBudget int64 `protobuf:"varint,2,opt,name=daily_budget,json=dailyBudget" json:"daily_budget,omitempty"`
	// unique location id representing city/zip/state/etc
	// https://fusiontables.google.com/DataSource?docid=1GF8rHWjkeLDLDt1WpqujyCelrgd0hq4bGYobmXAn
	LocationId int64 `protobuf:"varint,3,opt,name=location_id,json=locationId" json:"location_id,omitempty"`
}

func (m *GetCampaignPerformanceEstimationRequest) Reset() {
	*m = GetCampaignPerformanceEstimationRequest{}
}
func (m *GetCampaignPerformanceEstimationRequest) String() string { return proto.CompactTextString(m) }
func (*GetCampaignPerformanceEstimationRequest) ProtoMessage()    {}
func (*GetCampaignPerformanceEstimationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4}
}

func (m *GetCampaignPerformanceEstimationRequest) GetKeywordRequests() []*KeywordEstimationRequest {
	if m != nil {
		return m.KeywordRequests
	}
	return nil
}

func (m *GetCampaignPerformanceEstimationRequest) GetDailyBudget() int64 {
	if m != nil {
		return m.DailyBudget
	}
	return 0
}

func (m *GetCampaignPerformanceEstimationRequest) GetLocationId() int64 {
	if m != nil {
		return m.LocationId
	}
	return 0
}

// A performance estimation for a single keyword
type KeywordEstimation struct {
	// The keyword this estimate is for
	Keyword *Keyword `protobuf:"bytes,1,opt,name=keyword" json:"keyword,omitempty"`
	// The upper and lower bounds of the estimate
	Range *PerformanceEstimateRange `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
}

func (m *KeywordEstimation) Reset()                    { *m = KeywordEstimation{} }
func (m *KeywordEstimation) String() string            { return proto.CompactTextString(m) }
func (*KeywordEstimation) ProtoMessage()               {}
func (*KeywordEstimation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *KeywordEstimation) GetKeyword() *Keyword {
	if m != nil {
		return m.Keyword
	}
	return nil
}

func (m *KeywordEstimation) GetRange() *PerformanceEstimateRange {
	if m != nil {
		return m.Range
	}
	return nil
}

// An upper and lower bounded range of performance estimations
type PerformanceEstimateRange struct {
	// Minimum bound of the estimate
	Min *PerformanceEstimation `protobuf:"bytes,1,opt,name=min" json:"min,omitempty"`
	// Maximum bound of the estimate
	Max *PerformanceEstimation `protobuf:"bytes,2,opt,name=max" json:"max,omitempty"`
}

func (m *PerformanceEstimateRange) Reset()                    { *m = PerformanceEstimateRange{} }
func (m *PerformanceEstimateRange) String() string            { return proto.CompactTextString(m) }
func (*PerformanceEstimateRange) ProtoMessage()               {}
func (*PerformanceEstimateRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PerformanceEstimateRange) GetMin() *PerformanceEstimation {
	if m != nil {
		return m.Min
	}
	return nil
}

func (m *PerformanceEstimateRange) GetMax() *PerformanceEstimation {
	if m != nil {
		return m.Max
	}
	return nil
}

// Performance Stats which were estimated for a target
type PerformanceEstimation struct {
	// Estimate of average cost per click (in Micros)
	AverageCpc int64 `protobuf:"varint,1,opt,name=average_cpc,json=averageCpc" json:"average_cpc,omitempty"`
	// Estimate of average position in search results
	AveragePosition float64 `protobuf:"fixed64,2,opt,name=average_position,json=averagePosition" json:"average_position,omitempty"`
	// Estimate of possible clicks per day
	ClicksPerDay float32 `protobuf:"fixed32,3,opt,name=clicks_per_day,json=clicksPerDay" json:"clicks_per_day,omitempty"`
	// Estimate of possible click-throughs per day
	ClickThroughRate float64 `protobuf:"fixed64,4,opt,name=click_through_rate,json=clickThroughRate" json:"click_through_rate,omitempty"`
	// Estimate of possible impressions per day
	ImpressionsPerDay float32 `protobuf:"fixed32,5,opt,name=impressions_per_day,json=impressionsPerDay" json:"impressions_per_day,omitempty"`
	// Estimate of total cost per day (in Micros)
	TotalCost int64 `protobuf:"varint,6,opt,name=total_cost,json=totalCost" json:"total_cost,omitempty"`
}

func (m *PerformanceEstimation) Reset()                    { *m = PerformanceEstimation{} }
func (m *PerformanceEstimation) String() string            { return proto.CompactTextString(m) }
func (*PerformanceEstimation) ProtoMessage()               {}
func (*PerformanceEstimation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PerformanceEstimation) GetAverageCpc() int64 {
	if m != nil {
		return m.AverageCpc
	}
	return 0
}

func (m *PerformanceEstimation) GetAveragePosition() float64 {
	if m != nil {
		return m.AveragePosition
	}
	return 0
}

func (m *PerformanceEstimation) GetClicksPerDay() float32 {
	if m != nil {
		return m.ClicksPerDay
	}
	return 0
}

func (m *PerformanceEstimation) GetClickThroughRate() float64 {
	if m != nil {
		return m.ClickThroughRate
	}
	return 0
}

func (m *PerformanceEstimation) GetImpressionsPerDay() float32 {
	if m != nil {
		return m.ImpressionsPerDay
	}
	return 0
}

func (m *PerformanceEstimation) GetTotalCost() int64 {
	if m != nil {
		return m.TotalCost
	}
	return 0
}

// Response containing Campaign/Keyword Performance Estimates
type GetCampaignPerformanceEstimationResponse struct {
	// A list of keywords and their estimates
	KeywordEstimates []*KeywordEstimation `protobuf:"bytes,1,rep,name=keywordEstimates" json:"keywordEstimates,omitempty"`
}

func (m *GetCampaignPerformanceEstimationResponse) Reset() {
	*m = GetCampaignPerformanceEstimationResponse{}
}
func (m *GetCampaignPerformanceEstimationResponse) String() string { return proto.CompactTextString(m) }
func (*GetCampaignPerformanceEstimationResponse) ProtoMessage()    {}
func (*GetCampaignPerformanceEstimationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{8}
}

func (m *GetCampaignPerformanceEstimationResponse) GetKeywordEstimates() []*KeywordEstimation {
	if m != nil {
		return m.KeywordEstimates
	}
	return nil
}

// Request message for the GetAccountPerformance endpoint
type GetAccountPerformanceRequest struct {
	// An oauth refresh token authorized against an adwords account
	OauthRefreshToken string `protobuf:"bytes,1,opt,name=oauth_refresh_token,json=oauthRefreshToken" json:"oauth_refresh_token,omitempty"`
	// The CID of the account to fetch stats for
	CustomerId int64 `protobuf:"varint,2,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
}

func (m *GetAccountPerformanceRequest) Reset()                    { *m = GetAccountPerformanceRequest{} }
func (m *GetAccountPerformanceRequest) String() string            { return proto.CompactTextString(m) }
func (*GetAccountPerformanceRequest) ProtoMessage()               {}
func (*GetAccountPerformanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetAccountPerformanceRequest) GetOauthRefreshToken() string {
	if m != nil {
		return m.OauthRefreshToken
	}
	return ""
}

func (m *GetAccountPerformanceRequest) GetCustomerId() int64 {
	if m != nil {
		return m.CustomerId
	}
	return 0
}

// Response containing a stats summary for an account
type GetAccountPerformanceResponse struct {
	// Sum of all clicks from all campaigns on the account
	Clicks int64 `protobuf:"varint,1,opt,name=clicks" json:"clicks,omitempty"`
	// Sum of all impressions from all campaigns on the account
	Impressions int64 `protobuf:"varint,2,opt,name=impressions" json:"impressions,omitempty"`
	// Sum of cost of all clicks and impressions on the account
	Cost int64 `protobuf:"varint,3,opt,name=cost" json:"cost,omitempty"`
	// The number of conversions for all conversion actions
	Conversions float64 `protobuf:"fixed64,4,opt,name=conversions" json:"conversions,omitempty"`
	// The best estimate of total conversions driven by adwords
	AllConversions float64 `protobuf:"fixed64,5,opt,name=all_conversions,json=allConversions" json:"all_conversions,omitempty"`
}

func (m *GetAccountPerformanceResponse) Reset()                    { *m = GetAccountPerformanceResponse{} }
func (m *GetAccountPerformanceResponse) String() string            { return proto.CompactTextString(m) }
func (*GetAccountPerformanceResponse) ProtoMessage()               {}
func (*GetAccountPerformanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetAccountPerformanceResponse) GetClicks() int64 {
	if m != nil {
		return m.Clicks
	}
	return 0
}

func (m *GetAccountPerformanceResponse) GetImpressions() int64 {
	if m != nil {
		return m.Impressions
	}
	return 0
}

func (m *GetAccountPerformanceResponse) GetCost() int64 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *GetAccountPerformanceResponse) GetConversions() float64 {
	if m != nil {
		return m.Conversions
	}
	return 0
}

func (m *GetAccountPerformanceResponse) GetAllConversions() float64 {
	if m != nil {
		return m.AllConversions
	}
	return 0
}

// An Adwords Account description
type Account struct {
	// The Account's ID; i.e. CID
	CustomerId int64 `protobuf:"varint,1,opt,name=customer_id,json=customerId" json:"customer_id,omitempty"`
	// Display name for the account
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Is this a manager account (i.e. MCC)?
	IsManager bool `protobuf:"varint,3,opt,name=is_manager,json=isManager" json:"is_manager,omitempty"`
	// Is this a test account?
	IsTestAccount bool `protobuf:"varint,4,opt,name=is_test_account,json=isTestAccount" json:"is_test_account,omitempty"`
	// The ISO 4217 currency code of the account
	CurrencyCode string `protobuf:"bytes,5,opt,name=currency_code,json=currencyCode" json:"currency_code,omitempty"`
	// List of timezones here: https://developers.google.com/adwords/api/docs/appendix/codes-formats#timezone-ids
	TimeZone string `protobuf:"bytes,6,opt,name=time_zone,json=timeZone" json:"time_zone,omitempty"`
}

func (m *Account) Reset()                    { *m = Account{} }
func (m *Account) String() string            { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()               {}
func (*Account) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Account) GetCustomerId() int64 {
	if m != nil {
		return m.CustomerId
	}
	return 0
}

func (m *Account) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Account) GetIsManager() bool {
	if m != nil {
		return m.IsManager
	}
	return false
}

func (m *Account) GetIsTestAccount() bool {
	if m != nil {
		return m.IsTestAccount
	}
	return false
}

func (m *Account) GetCurrencyCode() string {
	if m != nil {
		return m.CurrencyCode
	}
	return ""
}

func (m *Account) GetTimeZone() string {
	if m != nil {
		return m.TimeZone
	}
	return ""
}

// Request message for the ListAccountsAccessibleByToken endpoint
type ListAllAccountsRequest struct {
	// An oauth refresh token authorized against an adwords account
	OauthRefreshToken string `protobuf:"bytes,1,opt,name=oauth_refresh_token,json=oauthRefreshToken" json:"oauth_refresh_token,omitempty"`
}

func (m *ListAllAccountsRequest) Reset()                    { *m = ListAllAccountsRequest{} }
func (m *ListAllAccountsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListAllAccountsRequest) ProtoMessage()               {}
func (*ListAllAccountsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ListAllAccountsRequest) GetOauthRefreshToken() string {
	if m != nil {
		return m.OauthRefreshToken
	}
	return ""
}

// Response containing all accounts accessible by the provided token
type ListAllAccountsResponse struct {
	Accounts []*Account `protobuf:"bytes,1,rep,name=accounts" json:"accounts,omitempty"`
}

func (m *ListAllAccountsResponse) Reset()                    { *m = ListAllAccountsResponse{} }
func (m *ListAllAccountsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListAllAccountsResponse) ProtoMessage()               {}
func (*ListAllAccountsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ListAllAccountsResponse) GetAccounts() []*Account {
	if m != nil {
		return m.Accounts
	}
	return nil
}

func init() {
	proto.RegisterType((*GetKeywordSuggestionsRequest)(nil), "adwords.v1.GetKeywordSuggestionsRequest")
	proto.RegisterType((*GetKeywordSuggestionsResponse)(nil), "adwords.v1.GetKeywordSuggestionsResponse")
	proto.RegisterType((*Keyword)(nil), "adwords.v1.Keyword")
	proto.RegisterType((*KeywordEstimationRequest)(nil), "adwords.v1.KeywordEstimationRequest")
	proto.RegisterType((*GetCampaignPerformanceEstimationRequest)(nil), "adwords.v1.GetCampaignPerformanceEstimationRequest")
	proto.RegisterType((*KeywordEstimation)(nil), "adwords.v1.KeywordEstimation")
	proto.RegisterType((*PerformanceEstimateRange)(nil), "adwords.v1.PerformanceEstimateRange")
	proto.RegisterType((*PerformanceEstimation)(nil), "adwords.v1.PerformanceEstimation")
	proto.RegisterType((*GetCampaignPerformanceEstimationResponse)(nil), "adwords.v1.GetCampaignPerformanceEstimationResponse")
	proto.RegisterType((*GetAccountPerformanceRequest)(nil), "adwords.v1.GetAccountPerformanceRequest")
	proto.RegisterType((*GetAccountPerformanceResponse)(nil), "adwords.v1.GetAccountPerformanceResponse")
	proto.RegisterType((*Account)(nil), "adwords.v1.Account")
	proto.RegisterType((*ListAllAccountsRequest)(nil), "adwords.v1.ListAllAccountsRequest")
	proto.RegisterType((*ListAllAccountsResponse)(nil), "adwords.v1.ListAllAccountsResponse")
	proto.RegisterEnum("adwords.v1.Keyword_MatchType", Keyword_MatchType_name, Keyword_MatchType_value)
}

func init() { proto.RegisterFile("adwords_service/v1/adwords.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x56, 0xcb, 0x73, 0xdb, 0x44,
	0x18, 0x47, 0x76, 0x9d, 0x58, 0x9f, 0xd3, 0xc4, 0xd9, 0x0c, 0xad, 0x06, 0x1a, 0x70, 0x45, 0x87,
	0x9a, 0x81, 0x3a, 0xd3, 0xf4, 0x06, 0x5c, 0x12, 0x37, 0xd3, 0x06, 0xfa, 0xc8, 0x6c, 0xcd, 0x0c,
	0xc3, 0x45, 0xb3, 0x95, 0xbe, 0x28, 0x9a, 0x48, 0x5a, 0xb1, 0xbb, 0x72, 0x6c, 0x0e, 0x5c, 0x60,
	0x38, 0xf0, 0x17, 0x71, 0xe2, 0xca, 0x0c, 0x7f, 0x15, 0xb3, 0x0f, 0x39, 0x26, 0x4e, 0xcb, 0xe3,
	0xa6, 0xfd, 0x7d, 0xef, 0xdf, 0xf7, 0x18, 0xc1, 0x80, 0x25, 0x17, 0x5c, 0x24, 0x32, 0x92, 0x28,
	0xa6, 0x59, 0x8c, 0x7b, 0xd3, 0x87, 0x7b, 0x0e, 0x1a, 0x55, 0x82, 0x2b, 0x4e, 0xa0, 0x79, 0x4e,
	0x1f, 0x86, 0x7f, 0xb6, 0xe0, 0xce, 0x13, 0x54, 0x5f, 0xe3, 0x5c, 0x43, 0xaf, 0xea, 0x34, 0x45,
	0xa9, 0x32, 0x5e, 0x4a, 0x8a, 0xdf, 0xd7, 0x28, 0x15, 0xf9, 0x10, 0x7a, 0x12, 0x99, 0x88, 0xcf,
	0x22, 0x85, 0xa2, 0x08, 0xbc, 0x41, 0x7b, 0xe8, 0x53, 0xb0, 0xd0, 0x04, 0x45, 0x41, 0xee, 0x80,
	0x9f, 0x95, 0x71, 0x5e, 0x27, 0x59, 0x99, 0x06, 0x2d, 0x23, 0xbe, 0x04, 0xb4, 0x14, 0x67, 0x8d,
	0xb4, 0x6d, 0xa5, 0x0b, 0x80, 0xbc, 0x07, 0xdd, 0x9c, 0x95, 0x69, 0xcd, 0x52, 0x0c, 0x6e, 0x0c,
	0xda, 0xc3, 0x36, 0x5d, 0xbc, 0x75, 0xe0, 0x98, 0x29, 0x4c, 0xb9, 0x98, 0x47, 0x59, 0x12, 0x74,
	0x06, 0xed, 0x61, 0x87, 0x42, 0x03, 0x1d, 0x27, 0xe4, 0x2e, 0x6c, 0xd8, 0x38, 0x18, 0x95, 0xf2,
	0xf4, 0x22, 0x58, 0x1b, 0x78, 0xc3, 0x2e, 0xed, 0x39, 0xec, 0x85, 0x3c, 0xbd, 0x20, 0x9f, 0xc2,
	0x76, 0xcc, 0x8b, 0x0a, 0x55, 0xa6, 0x6b, 0x8a, 0x72, 0x9c, 0x62, 0x1e, 0xac, 0x0f, 0xbc, 0x61,
	0x87, 0xf6, 0x97, 0x04, 0xcf, 0x34, 0xae, 0x03, 0x0a, 0xcc, 0x99, 0xc2, 0x24, 0xaa, 0x45, 0x1e,
	0x74, 0x6d, 0xa5, 0x0e, 0xfa, 0x46, 0x18, 0x85, 0x9c, 0xc7, 0xcc, 0xb8, 0xca, 0x92, 0xc0, 0x1f,
	0x78, 0xc3, 0x36, 0x85, 0x06, 0x3a, 0x4e, 0xc2, 0x2f, 0x60, 0xf7, 0x0d, 0x5c, 0xca, 0x8a, 0x97,
	0x12, 0x75, 0xbd, 0xe7, 0x56, 0x2a, 0x1d, 0x93, 0x8b, 0x77, 0xf8, 0xab, 0x07, 0xeb, 0xce, 0x94,
	0x10, 0xb8, 0xa1, 0x70, 0xa6, 0x02, 0x6f, 0xe0, 0x0d, 0x7d, 0x6a, 0xbe, 0xc9, 0x97, 0x00, 0x05,
	0x53, 0xba, 0x0f, 0xf3, 0x0a, 0x83, 0xd6, 0xc0, 0x1b, 0x6e, 0xee, 0xef, 0x8e, 0x2e, 0x5b, 0x39,
	0x72, 0xc6, 0xa3, 0xe7, 0x5a, 0x6b, 0x32, 0xaf, 0x90, 0xfa, 0x45, 0xf3, 0x19, 0x3e, 0x00, 0x7f,
	0x81, 0x13, 0x1f, 0x3a, 0x47, 0xdf, 0x1e, 0x8c, 0x27, 0xfd, 0x77, 0xf4, 0xe7, 0x21, 0x7d, 0x79,
	0xf0, 0xb8, 0xef, 0x11, 0x80, 0xb5, 0x93, 0xa7, 0xf4, 0xe0, 0xd5, 0x51, 0xbf, 0x15, 0xfe, 0xe4,
	0x41, 0xe0, 0xfc, 0x1d, 0x49, 0x95, 0x15, 0xa6, 0xc2, 0x66, 0x24, 0x1e, 0xc0, 0xba, 0xcb, 0xda,
	0x24, 0xd8, 0xdb, 0xdf, 0xb9, 0x26, 0x0d, 0xda, 0xe8, 0x68, 0xda, 0x32, 0x19, 0x95, 0x98, 0x32,
	0x95, 0x4d, 0x6d, 0xe6, 0x5d, 0x0a, 0x99, 0x7c, 0xe1, 0x10, 0x72, 0x1b, 0xd6, 0x0b, 0x36, 0x8b,
	0xe2, 0x2a, 0x0e, 0xda, 0x86, 0xd3, 0xb5, 0x82, 0xcd, 0xc6, 0x55, 0x1c, 0xfe, 0xee, 0xc1, 0xfd,
	0x27, 0xa8, 0xc6, 0xac, 0xa8, 0x58, 0x96, 0x96, 0x27, 0x28, 0x4e, 0xb9, 0x28, 0x58, 0x19, 0xe3,
	0x6a, 0x52, 0x2f, 0xa1, 0xef, 0x02, 0x46, 0xc2, 0x42, 0x96, 0xe2, 0xde, 0xfe, 0xbd, 0x6b, 0xb2,
	0x5b, 0xb1, 0xa7, 0x5b, 0xce, 0xda, 0xbd, 0xa5, 0x1e, 0xaf, 0x84, 0x65, 0xf9, 0x3c, 0x7a, 0x5d,
	0x27, 0x29, 0x2a, 0x93, 0x77, 0x9b, 0xf6, 0x0c, 0x76, 0x68, 0xa0, 0xab, 0x03, 0xd1, 0x5e, 0x19,
	0x88, 0x1f, 0x61, 0x7b, 0x25, 0xe0, 0x7f, 0xa5, 0xef, 0x73, 0xe8, 0x08, 0x56, 0xa6, 0x96, 0xb8,
	0x2b, 0xd5, 0xac, 0x32, 0x82, 0x54, 0xeb, 0x52, 0x6b, 0x12, 0xfe, 0xec, 0x41, 0xf0, 0x26, 0x1d,
	0xf2, 0x08, 0xda, 0x45, 0x56, 0xba, 0x1c, 0xee, 0xbe, 0xdd, 0xad, 0x26, 0x4a, 0x6b, 0x1b, 0x23,
	0x36, 0x73, 0xb9, 0xfc, 0x2b, 0x23, 0x36, 0x0b, 0x7f, 0x69, 0xc1, 0xbb, 0xd7, 0x8a, 0x35, 0x83,
	0x6c, 0x8a, 0x82, 0xa5, 0x68, 0xda, 0xef, 0x59, 0x06, 0x1d, 0x34, 0xae, 0x62, 0xf2, 0x09, 0xf4,
	0x1b, 0x85, 0x8a, 0x4b, 0xb3, 0xad, 0x26, 0xb8, 0x47, 0xb7, 0x1c, 0x7e, 0xe2, 0x60, 0x72, 0x0f,
	0x36, 0xe3, 0x3c, 0x8b, 0xcf, 0x65, 0x54, 0xa1, 0x88, 0x12, 0x36, 0x37, 0x0d, 0x69, 0xd1, 0x0d,
	0x8b, 0x9e, 0xa0, 0x78, 0xcc, 0xe6, 0xe4, 0x33, 0x20, 0xe6, 0x1d, 0xa9, 0x33, 0xc1, 0xeb, 0xf4,
	0x2c, 0x12, 0x4c, 0xe9, 0xe3, 0xa3, 0x5d, 0xf6, 0x8d, 0x64, 0x62, 0x05, 0x94, 0x29, 0x24, 0x23,
	0xd8, 0xc9, 0x8a, 0x4a, 0xa0, 0x94, 0x7a, 0x8f, 0x17, 0x8e, 0x3b, 0xc6, 0xf1, 0xf6, 0x92, 0xc8,
	0x79, 0xdf, 0x05, 0x50, 0x5c, 0xb1, 0x3c, 0x8a, 0xb9, 0x54, 0xe6, 0x22, 0xb5, 0xa9, 0x6f, 0x90,
	0x31, 0x97, 0x2a, 0xac, 0x61, 0xf8, 0xcf, 0xf3, 0xec, 0x6e, 0xc5, 0xf1, 0x62, 0xa0, 0x9b, 0xb6,
	0x35, 0x03, 0xbd, 0xfb, 0xf6, 0x81, 0x5e, 0x31, 0x0b, 0xb9, 0xb9, 0xf1, 0x07, 0x71, 0xcc, 0xeb,
	0x52, 0x2d, 0x45, 0x6d, 0x76, 0x67, 0x04, 0x3b, 0x9c, 0xd5, 0xea, 0x2c, 0x12, 0x78, 0x2a, 0x50,
	0x9e, 0x45, 0x8a, 0x9f, 0x63, 0xe9, 0xae, 0xcf, 0xb6, 0x11, 0x51, 0x2b, 0x99, 0x68, 0x81, 0x39,
	0xcd, 0xb5, 0x54, 0xbc, 0x40, 0xa1, 0xe7, 0xde, 0x6e, 0x06, 0x34, 0xd0, 0x71, 0x12, 0xfe, 0xe6,
	0x99, 0x4b, 0x78, 0x5d, 0x44, 0x57, 0xdd, 0x2d, 0x58, 0xb3, 0x6d, 0x71, 0x3d, 0x77, 0x2f, 0x32,
	0x80, 0xde, 0x12, 0xab, 0xcd, 0xd2, 0x2d, 0x41, 0xfa, 0x36, 0x1a, 0x72, 0xed, 0xb6, 0x99, 0x6f,
	0x6d, 0x15, 0xf3, 0x72, 0x8a, 0xc2, 0x5a, 0xd9, 0x6e, 0x2e, 0x43, 0xe4, 0x3e, 0x6c, 0xb1, 0x5c,
	0xb7, 0xe5, 0x52, 0xab, 0x63, 0xb4, 0x36, 0x59, 0x9e, 0x8f, 0x2f, 0xd1, 0xf0, 0x0f, 0x0f, 0xd6,
	0x5d, 0xde, 0x57, 0xeb, 0xf4, 0xae, 0xd6, 0xa9, 0x73, 0x29, 0x59, 0x61, 0x57, 0xd3, 0xa7, 0xe6,
	0x5b, 0x8f, 0x40, 0x26, 0xa3, 0x82, 0x95, 0x2c, 0x45, 0x61, 0xb2, 0xec, 0x52, 0x3f, 0x93, 0xcf,
	0x2d, 0x40, 0x3e, 0x86, 0xad, 0x4c, 0x46, 0x0a, 0xa5, 0x8a, 0x98, 0x0d, 0x63, 0xd2, 0xed, 0xd2,
	0x9b, 0x99, 0x9c, 0xa0, 0x6c, 0x38, 0x23, 0x1f, 0xc1, 0xcd, 0xb8, 0x16, 0x02, 0xcb, 0x78, 0x1e,
	0xc5, 0x3c, 0x41, 0x93, 0xae, 0x4f, 0x37, 0x1a, 0x70, 0xcc, 0x13, 0x24, 0xef, 0x83, 0xaf, 0xb2,
	0x02, 0xa3, 0x1f, 0x78, 0x89, 0x66, 0xda, 0x7c, 0xda, 0xd5, 0xc0, 0x77, 0xbc, 0xc4, 0xf0, 0x29,
	0xdc, 0x7a, 0x96, 0x49, 0x75, 0x90, 0xe7, 0xce, 0xa7, 0xfc, 0x9f, 0xfd, 0x0e, 0xbf, 0x82, 0xdb,
	0x2b, 0x9e, 0x5c, 0x1f, 0xf7, 0xa0, 0xeb, 0xca, 0x68, 0xa6, 0xf3, 0x6f, 0xd7, 0xcc, 0xe9, 0xd3,
	0x85, 0xd2, 0x61, 0x08, 0x1f, 0xc4, 0xbc, 0x18, 0x4d, 0xb1, 0x4c, 0x98, 0x54, 0x6c, 0xa1, 0x9c,
	0x62, 0x89, 0x7a, 0x15, 0x93, 0x13, 0xef, 0xf5, 0x9a, 0xf9, 0x4f, 0x79, 0xf4, 0x57, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x9c, 0x12, 0x79, 0xbe, 0xcb, 0x08, 0x00, 0x00,
}
