package docker

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	mscliio "github.com/vendasta/mscli/pkg/io"
	"github.com/vendasta/mscli/pkg/spec"
	"github.com/vendasta/mscli/pkg/utils"
)

// CreateDockerfileBoilerplate generates a dockerfile for ci
func CreateDockerfileBoilerplate(spec spec.MicroserviceFile) error {
	data := DockerfileTemplateData{
		Name:          spec.Microservice.Name,
		GoPackageName: spec.Microservice.GoPackageName,
	}
	return mscliio.CreateTemplatedFile("./Dockerfile_mscli", data, DockerfileTemplate)
}

// BuildDockerImage builds a Docker image from a Dockerfile (generated by default)
func BuildDockerImage(spec spec.MicroserviceFile, version string) (string, error) {
	dockerfile := "./Dockerfile_mscli"

	if spec.Microservice.Dockerfile == "" {
		err := CreateDockerfileBoilerplate(spec)
		if err != nil {
			return "", err
		}
		defer mscliio.DeleteFile(dockerfile)
	} else {
		dockerfile = spec.Microservice.Dockerfile
	}

	tag := DockerImageTag(spec, version)
	_, err := mscliio.DockerCommand("build", "-f", dockerfile, "-t", tag, ".").Execute()
	if err != nil {
		return "", fmt.Errorf("Error building docker image: %s\n", err.Error())
	}
	return tag, nil
}

func DockerImageTag(spec spec.MicroserviceFile, version string) string {
	tag := fmt.Sprintf("gcr.io/repcore-prod/%s:%s", strings.ToLower(spec.Microservice.Name), version)
	return tag
}

// BuildCloudContainer uses cloud container builder to build and publish an image
func BuildCloudContainer(spec spec.MicroserviceFile, version string) error {
	dockerfile := "./Dockerfile"
	if spec.Microservice.Dockerfile == "" {
		// No custom Dockerfile, use the template to create one
		mscliio.CreateTemplatedFile("./cloudbuild.yaml", CloudbuildYamlTemplateData{OnJenkins: utils.IsOnJenkins(), Microservice: spec.Microservice}, CloudbuildYamlTemplate)
		defer mscliio.DeleteFile("./cloudbuild.yaml")
		mscliio.WriteFile(spec, CloudbuilderDockerfileTemplate, dockerfile, "{{", "}}")
		defer mscliio.DeleteFile(dockerfile)

		_, err := mscliio.RunCommand("gcloud", "container", "builds", "submit", ".", "--config", "cloudbuild.yaml",
			"--substitutions", fmt.Sprintf("_VERSION=%s", version), "--project",
			"repcore-prod").Execute()
		if err != nil {
			return fmt.Errorf("error building cloud container: %s", err.Error())
		}
	} else {
		// Use specified custom Dockerfile
		src, err := filepath.Abs(spec.Microservice.Dockerfile)
		if err != nil {
			return fmt.Errorf("failed to find %s: %s", spec.Microservice.Dockerfile, err.Error())
		}
		dest, err := filepath.Abs(dockerfile)
		if err != nil {
			return fmt.Errorf("failed to find %s: %s", dockerfile, err.Error())
		}
		if src != dest {
			// Custom Dockerfile was specified and it isn't called 'Dockerfile':
			// can't use docker -f arg, so use a temporary hardlink instead
			err := os.Link(src, dest)
			if err != nil {
				return fmt.Errorf("error linking %s to %s: %s", src, dest, err.Error())
			}
			defer mscliio.DeleteFile(dest)
		}

		_, err = mscliio.RunCommand("gcloud", "container", "builds", "submit", ".",
			"--tag", fmt.Sprintf("gcr.io/repcore-prod/%s:%s", spec.Microservice.Name, version),
			"--project", "repcore-prod").Execute()

		if err != nil {
			return fmt.Errorf("error building cloud container: %s", err.Error())
		}
	}
	return nil
}

// PushToContainerRegistry pushes a built image to the registry
func PushToContainerRegistry(dockerImage string) error {
	Login()
	_, err := mscliio.DockerCommand("push", dockerImage).Execute()
	if err != nil {
		return fmt.Errorf("Error pushing image %s to container registry: %s", dockerImage, err.Error())
	}
	return nil
}

// CopyLocalDockerTag will update the project's docker-compose, or legacy vbootstrap-compose yaml file with a new docker tag
func CopyLocalDockerTag(tag, name string) error {
	composeFile := "docker-compose.yaml"
	input, err := ioutil.ReadFile(composeFile)
	if err != nil {
		return fmt.Errorf("Error reading %s: %s", composeFile, err.Error())
	}
	re := regexp.MustCompile(fmt.Sprintf(`gcr.io/repcore-prod/%s:\d+`, name))
	lines := strings.Split(string(input), "\n")
	for i, line := range lines {
		lines[i] = re.ReplaceAllString(line, tag)
	}
	output := strings.Join(lines, "\n")
	err = ioutil.WriteFile(composeFile, []byte(output), 0644)
	if err != nil {
		return fmt.Errorf("Error writing %s: %s", composeFile, err.Error())
	}
	log.Printf("Updated %s with docker tag: %s", composeFile, tag)
	return nil
}

// Login to gcr.io Docker image repository
func Login() error {
	creds := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")
	if creds == "" {
		return nil
	}
	credsJSON, err := ioutil.ReadFile(creds)
	if err != nil {
		return fmt.Errorf("there were errors reading the json key. %s", err.Error())
	}

	_, err = mscliio.DockerCommand("login", "-e", "1234@5678.com", "-u", "_json_key", "-p", string(credsJSON), "https://gcr.io").Execute()

	if err != nil {
		return fmt.Errorf("error logging into GCR.io: %s", err.Error())
	}
	return nil
}
